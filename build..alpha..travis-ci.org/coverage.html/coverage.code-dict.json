{"/home/travis/build/npmtest/node-npmtest-share/test.js":"/* istanbul instrument in package npmtest_share */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-share/lib.npmtest_share.js":"/* istanbul instrument in package npmtest_share */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_share = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_share = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-share/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-share && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_share */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_share\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_share.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_share.rollup.js'] =\n            local.assetsDict['/assets.npmtest_share.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_share.__dirname + '/lib.npmtest_share.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/index.js":"exports.server = require('./server');\nexports.client = require('./client');\n\n// Type wrappers\nexports.types = require('./types');\n\n// Export the scripts directory to make it easy to host the scripts with connect. Do something like this:\n//  app.use('sharejs', connect.static(sharejs.scriptsDir));\nexports.scriptsDir = __dirname + '/../dist';\n\n// Expose db.mongo, db.etc - whatever else is in livedb.\nexports.db = require('livedb');\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/server/index.js":"var Session = require('./session');\nvar UserAgent = require('./useragent');\nvar livedb = require('livedb');\n\n/** This encapsulates the sharejs server state & exposes a few useful methods.\n *\n * @constructor\n */\nvar ShareInstance = function(options) {\n  this.options = options;\n\n  this.preValidate = options.preValidate;\n  this.validate = options.validate;\n\n  if (options.backend) {\n    this.backend = options.backend;\n  } else if (options.db) {\n    this.backend = livedb.client(options.db);\n  } else {\n    throw Error(\"Both options.backend and options.db are missing. Can't function without a database!\");\n  }\n\n  // Map from event name (or '') to a list of middleware.\n  this.extensions = {'':[]};\n  this.docFilters = [];\n  this.opFilters = [];\n};\n\n/** A client has connected through the specified stream. Listen for messages.\n * Returns the useragent associated with the connected session.\n *\n * The optional second argument (req) is an initial request which is passed\n * through to any connect() middleware. This is useful for inspecting cookies\n * or an express session or whatever on the request object in your middleware.\n *\n * (The useragent is available through all middleware)\n */\nShareInstance.prototype.listen = function(stream, req) {\n  var session = this.createSession(stream);\n  session.agent.trigger('connect', null, null, {stream: stream, req: req}, function(err) {\n    if (err) return session.close(err);\n    session.pump();\n  });\n  return session.agent;\n};\n\n// Create and return REST middleware to access the documents\nShareInstance.prototype.rest = function() {\n  var rest = require('./rest');\n  return rest(this);\n};\n\n\n/** Add middleware to an action. The action is optional (if not specified, the\n * middleware fires on every action).\n */\nShareInstance.prototype.use = function(action, middleware) {\n  if (typeof action !== 'string') {\n    middleware = action;\n    action = '';\n  }\n\n  if (action === 'getOps') {\n    throw new Error(\"The 'getOps' middleware action has been renamed to 'get ops'. Update your code.\");\n  }\n\n  var extensions = this.extensions[action];\n  if (!extensions) extensions = this.extensions[action] = [];\n\n  extensions.push(middleware);\n};\n\n\n/** Add a function to filter all data going to the current client */\nShareInstance.prototype.filter = function(fn) {\n  this.docFilters.push(fn);\n};\n\nShareInstance.prototype.filterOps = function(fn) {\n  this.opFilters.push(fn);\n};\n\nShareInstance.prototype.createAgent = function(stream) {\n  return new UserAgent(this, stream);\n};\n\nShareInstance.prototype.createSession = function(stream) {\n  return new Session(this, stream);\n};\n\n// Return truthy if the instance has registered middleware. Used for bulkSubscribe.\nShareInstance.prototype._hasMiddleware = function(action) {\n  return this.extensions[action];\n};\n\n\n/**\n * Passes request through the extensions stack\n *\n * Extensions may modify the request object. After all middlewares have been\n * invoked we call `callback` with `null` and the modified request.\n * If one of the extensions resturns an error the callback is called with that\n * error.\n */\nShareInstance.prototype._trigger = function(request, callback) {\n  // Copying the triggers we'll fire so they don't get edited while we iterate.\n  var middlewares = (this.extensions[request.action] || []).concat(this.extensions['']);\n\n  var next = function() {\n    if (!middlewares.length)\n      return callback ? callback(null, request) : undefined;\n\n    var middleware = middlewares.shift();\n    middleware(request, function(err) {\n      if (err) return callback ? callback(err) : undefined;\n\n      next();\n    });\n  };\n\n  next();\n};\n\nexports.createClient = function(options) {\n  return new ShareInstance(options);\n};\n\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/server/session.js":"// This implements the network API for ShareJS.\n//\n// The wire protocol is speccced out here:\n// https://github.com/josephg/ShareJS/wiki/Wire-Protocol\n//\n// When a client connects the server first authenticates it and sends:\n//\n// S: {id:<agent session id>}\n//\n// After that, the client can open documents:\n//\n// C: {c:'users', d:'fred', sub:true, snapshot:null, create:true, type:'text'}\n// S: {c:'users', d:'fred', sub:true, snapshot:{snapshot:'hi there', v:5, meta:{}}, create:false}\n//\n// ...\n//\n// The client can send open requests as soon as the socket has opened - it doesn't need to\n// wait for its id.\n//\n// The wire protocol is documented here:\n// https://github.com/josephg/ShareJS/wiki/Wire-Protocol\n\nvar hat = require('hat');\nvar assert = require('assert');\n\n// stream is a nodejs 0.10 stream object.\n/**\n * @param {ShareInstance} instance\n * @param {Duplex} stream\n * @param {Http.Request} req\n */\nmodule.exports = Session;\n\n/**\n * Session deserializes the wire protocol messages received from the stream and\n * calls the corresponding functions on its UserAgent. It uses the return values\n * to send responses back. Session also handles piping the operation streams\n * provided by a UserAgent.\n *\n * @param {ShareInstance} instance\n * @param {Duplex} stream connection to a client\n */\nfunction Session(instance, stream) {\n  // The stream passed in should be a nodejs 0.10-style stream.\n  this.stream = stream;\n\n  // This is the user agent through which a connecting client acts.  The agent\n  // is responsible for making sure client requests are properly authorized,\n  // and metadata is kept up to date.\n  this.agent = instance.createAgent(stream);\n  this.agent.session = this;\n\n  // We need to track which documents are subscribed by the client. This is a\n  // map of collection name -> {doc name: stream || true || false}\n  this.collections = {};\n\n  // Map from query ID -> emitter.\n  this.queries = {};\n\n  // Subscriptions care about the stream being destroyed. We end up with a\n  // listener per subscribed document for the client, which can be a lot.\n  stream.setMaxListeners(0);\n\n  // We need to track this manually to make sure we don't reply to messages\n  // after the stream was closed. There's no built-in way to ask a stream\n  // whether its actually still open.\n  this.closed = false;\n\n  stream.once('end', this._cleanup.bind(this));\n\n  // Initialize the remote client by sending it its session Id.\n  this._send({a:'init', protocol:0, id:this.agent.sessionId});\n}\n\nSession.prototype._cleanup = function() {\n  if (this.closed) return\n  this.closed = true;\n\n  // Remove the pump listener\n  this.stream.removeAllListeners('readable');\n\n  // Clean up all the subscriptions.\n  for (var c in this.collections) {\n    for (var docName in this.collections[c]) {\n      var value = this.collections[c][docName];\n      // Value can be true, false or a stream. true means we're in the\n      // process of subscribing the client.\n      if (typeof value === 'object') {\n        destroyStream(value);\n      }\n      this.collections[c][docName] = false; // cancel the subscribe\n    }\n  }\n\n  for (var id in this.queries) {\n    var emitter = this.queries[id];\n    emitter.destroy();\n    delete this.queries[id];\n  }\n};\n\n// Close the session with the client.\nSession.prototype.close = function(err) {\n  if (err) {\n    console.warn('Session closed due to error', err);\n    this.stream.emit('error', err);\n  }\n  if (this.closed) return;\n  // This will emit 'end', which will call _cleanup\n  this.stream.end();\n};\n\n// Mark a document as subscribed or unsubscribed. The value is stored\n// associated with the subscription. It is set to true (subscribing), false\n// (unsubscribed) or the actual operation stream.\nSession.prototype._setSubscribed = function(collection, docName, value) {\n  var docs = this.collections[collection] || (this.collections[collection] = {});\n  // Check to see if already subscribed\n  var previous = docs[docName];\n  if (typeof value === 'object') {\n    if (previous !== true) {\n      // The document has been unsubscribed or replaced with another stream\n      // already. Either way, we destroy the new stream, since the existing\n      // stream should have been subscribed the whole time. Possible I might be\n      // missing some race condition and we might miss a message (nateps)\n      destroyStream(value);\n      return previous;\n    }\n  } else if (value === true) {\n    // Reject replacing subscribed stream or subscribing state with\n    // a new subscribing state\n    if (previous) {\n      // Return existing stream or subscribing state on failure\n      return previous;\n    }\n  } else {\n    // Unsubscribe\n    if (typeof previous === 'object') {\n      destroyStream(previous);\n    }\n  }\n  // Set to new value\n  docs[docName] = value;\n  // Returns nothing on success\n};\n\n// Check whether or not the document is subscribed by this session.\nSession.prototype._isSubscribed = function(c, docName) {\n  return this.collections[c] && this.collections[c][docName];\n};\n\n/**\n * Passes operation data received on opstream to the session stream via\n * _sendOp()\n */\nSession.prototype._subscribeToStream = function(collection, docName, opstream) {\n  var previous = this._setSubscribed(collection, docName, opstream);\n  // Our set was rejected and our stream was destroyed, so just return\n  if (previous) return;\n\n  var self = this;\n  // This should use the new streams API instead of the old one.\n  opstream.on('data', onData);\n  function onData(data) {\n    self._sendOp(collection, docName, data);\n  };\n  opstream.once('end', function() {\n    // Livedb has closed the op stream. What do we do here? Normally this\n    // shouldn't happen unless we're cleaning up, so I'll assume thats whats\n    // happening now.\n    self._setSubscribed(collection, docName, false);\n    opstream.removeListener('data', onData);\n  });\n};\n\n// Subscribe to the named document at the specified version. The version is\n// optional.\nSession.prototype._subscribe = function(collection, docName, v, callback) {\n  var self = this;\n  this._setSubscribed(collection, docName, true);\n\n  if (v != null) {\n    // This logic is mirrored in _processQueryResults below. If you change\n    // how it works, update that function too.\n    // Yes, I know I'm a bad person.\n    this.agent.subscribe(collection, docName, v, function(err, opstream) {\n      if (err) {\n        self._setSubscribed(collection, docName, false);\n        return callback(err);\n      }\n      self._subscribeToStream(collection, docName, opstream);\n      callback();\n    });\n  } else {\n    // Rewrite me to not use fetchAndSubscribe.\n    this.agent.fetchAndSubscribe(collection, docName, function(err, data, opstream) {\n      if (err) {\n        self._setSubscribed(collection, docName, false);\n        return callback(err);\n      }\n      self._subscribeToStream(collection, docName, opstream);\n      callback(null, data);\n    });\n  }\n};\n\n// Bulk subscribe. The message is:\n// {a:'bs', d:{users:{fred:100, george:5, carl:null}, cname:{...}}}\nSession.prototype.bulkSubscribe = function(request, callback) {\n  // For each document there are three cases:\n  // - The document is already subscribed. Do nothing\n  // - The client doesn't have a snapshot (v=null). We need to do a fetch then ...\n  // - The client has a snapshot already (most common case) and is resubscribing. We need to subscribe.\n\n  // This is a bulk fetch request for all documents that the client doesn't have data for.\n  var needFetch = {};\n\n  // The eventual response.\n  var response = {};\n\n  for (var cName in request) {\n    var docs = request[cName];\n    // Every doc in the request will get a response.\n    response[cName] = {};\n    for (var docName in docs) {\n      // Mark the subscription.\n      this._setSubscribed(cName, docName, true);\n\n      // Populate the bulk fetch request.\n      if (docs[docName] == null) {\n        needFetch[cName] = needFetch[cName] || [];\n        needFetch[cName].push(docName);\n      }\n    }\n  }\n\n  var self = this;\n  var agent = this.agent;\n\n  // Next we do a bulkFetch on all the items that need a fetchin'. If no\n  // documents need a fetch, this returns into the callback immediately.\n  agent.bulkFetch(needFetch, function(err, snapshots) {\n    if (err) {\n      // For now, just abort the whole bundle on error. We could be more\n      // neuanced about this, but I'll wait for a use case.\n      self._cancelBulk(request);\n      return callback(err);\n    }\n\n    for (var cName in snapshots) {\n      for (var docName in snapshots[cName]) {\n        var snapshot = snapshots[cName][docName];\n        // Set the version that we'll subscribe to\n        request[cName][docName] = snapshot.v;\n        // Set the snapshot in the response\n        response[cName][docName] = snapshot;\n      }\n    }\n\n    agent.bulkSubscribe(request, function(err, streams) {\n      if (err) {\n        self._cancelBulk(request);\n        return callback(err);\n      }\n\n      for (var cName in streams) {\n        for (var docName in streams[cName]) {\n          // Just give a thumbs up for the subscription.\n          response[cName][docName] = response[cName][docName] || true;\n\n          var v = request[cName][docName].v;\n          self._subscribeToStream(cName, docName, streams[cName][docName]);\n        }\n      }\n\n      callback(null, response);\n    });\n  });\n};\n\nSession.prototype._cancelBulk = function(request) {\n  // Cancel the subscribed state on the documents.\n  for (var cName in request) {\n    var docs = request[cName];\n    for (var docName in docs) {\n      this._setSubscribed(cName, docName, false);\n    }\n  }\n};\n\n// Send a message to the remote client.\nSession.prototype._send = function(msg) {\n  // Quietly drop replies if the stream was closed\n  if (this.closed) return;\n\n  this.stream.write(msg);\n};\n\nSession.prototype._sendOp = function(collection, docName, data) {\n  var msg = {\n    a: 'op',\n    c: collection,\n    d: docName,\n    v: data.v,\n    src: data.src,\n    seq: data.seq\n  };\n\n  // In theory, we only need to send the operation data if data.src !==\n  // this.agent.sessionId. However, this doesn't work with projections because\n  // the client needs to see their own operations in the projected collection.\n  //\n  // I'd like to reinstate this optimization, but I can't think of a good way to\n  // do it while making projections work. For now, you get your own operations\n  // back.\n  if (data.op) msg.op = data.op;\n  if (data.create) msg.create = data.create;\n  if (data.del) msg.del = true;\n\n  this._send(msg);\n};\n\nSession.prototype._reply = function(req, err, msg) {\n  if (err) {\n    msg = {a:req.a, error:err};\n  } else {\n    if (!msg.a) msg.a = req.a;\n  }\n\n  if (req.c) msg.c = req.c; // collection\n  if (req.d) msg.d = req.d; // docName\n  if (req.id) msg.id = req.id;\n\n  this._send(msg);\n};\n\n// start processing events from the stream. This calls itself recursively.\n// Use .close() to drain the pump.\nSession.prototype.pump = function() {\n  if (this.closed) return;\n\n  var req = this.stream.read();\n  var self = this;\n\n  if (req != null) {\n    if (typeof req === 'string') {\n      try {\n        req = JSON.parse(req);\n      } catch(e) {\n        console.warn('Client sent invalid JSON', e.stack);\n        self.close(e);\n      }\n    }\n    this._handleMessage(req, function(err, msg) {\n      if (err || msg) self._reply(req, err, msg);\n\n      // This is in a process.nextTick to avoid stack smashing attacks (since\n      // sometimes this callback function is called synchronously).\n      process.nextTick(function() {\n        self.pump();\n      });\n    });\n  } else {\n    // Retry when there's a message waiting for us.\n    this.stream.once('readable', this.pump.bind(this));\n  }\n};\n\n// Check a request to see if its valid. Returns an error if there's a problem.\nSession.prototype._checkRequest = function(req) {\n  if (req.a === 'qsub' || req.a === 'qfetch' || req.a === 'qunsub') {\n    // Query messages need an ID property.\n    if (typeof req.id !== 'number') return 'Missing query ID';\n  } else if (req.a === 'op' || req.a === 'sub' || req.a === 'unsub' || req.a === 'fetch') {\n    // Doc-based request.\n    if (req.c != null && typeof req.c !== 'string') return 'Invalid collection';\n    if (req.d != null && typeof req.d !== 'string') return 'Invalid docName';\n\n    if (req.a === 'op') {\n      if (req.v != null && (typeof req.v !== 'number' || req.v < 0)) return 'Invalid version';\n    }\n  } else if (req.a === 'bs') {\n    // Bulk subscribe\n    if (typeof req.s !== 'object') return 'Invalid bulk subscribe data';\n  } else {\n    return 'Invalid action';\n  }\n};\n\n// This function takes in results from livedb and returns a results set to be\n// sent to the sharejs client.\n//\n// Because I'm a moron, in livedb the snapshot data objects in\n// results look like {c:, docName:, v:, type:, data:}. ShareJS expects them to have\n// {c:, docName:, v:, type:, snapshot:}. So I have to rewrite them.\nSession.prototype._processQueryResults = function(collection, results, qopts) {\n  var self = this;\n  var messages = [];\n\n  // Types are only put in the result set for the first result and every time the type changes.\n  var lastType = null;\n  results.forEach(function(r) {\n    var docName = r.docName;\n\n    var message = {c:collection, d:docName, v:r.v};\n    messages.push(message);\n\n    if (lastType !== r.type) {\n      lastType = message.type = r.type;\n    }\n\n    if (qopts.docMode) {\n      var atVersion = qopts.versions && qopts.versions[collection] && qopts.versions[collection][docName];\n      // Only give the client snapshot data if the client requested it and they\n      // don't already have a copy of the document.\n      if (atVersion == null) {\n        message.data = r.data;\n      } else if (r.v > atVersion) {\n        // We won't put any op data into the response, but we'll send some\n        // normal ops to follow the query. This might not be the best idea - it\n        // means that sometimes the query will say that a document matches\n        // before you get the document's updated data.\n        self.agent.getOps(collection, docName, atVersion, -1, function(err, results) {\n          if (err) {\n            self._send({a:'fetch', c:collection, d:docName, error:err});\n            return;\n          }\n          for (var i = 0; i < results.length; i++) {\n            self._sendOp(collection, docName, results[i]);\n          }\n        });\n      }\n    }\n  });\n\n  return messages;\n};\n\n// Handle an incoming message from the client. This is the actual guts of session.js.\nSession.prototype._handleMessage = function(req, callback) {\n  // First some checks of the incoming request. Error will be set to a value if a problem is found.\n  var error;\n  if ((error = this._checkRequest(req))) {\n    console.warn('Warning: Invalid request from ', this.agent.sessionId, req, 'Error: ', error);\n    return callback(error);\n  }\n\n  if (req.a === 'qsub' || req.a === 'qfetch' || req.a === 'qunsub') {\n    // Query based request.\n\n    // Queries have an ID to refer to the particular query in the client\n    var qid = req.id;\n\n    // The index that will handle the query request. For mongo queries, this is\n    // simply the collection that contains the data.\n    var index = req.c;\n\n    // Options for liveDB.query.\n    var qopts = {};\n\n    if (req.o) {\n      // Do we send back document snapshots for the results? Either 'fetch' or 'sub'.\n      qopts.docMode = req.o.m;\n      if (qopts.docMode != null && qopts.docMode !== 'fetch' && qopts.docMode !== 'sub')\n        return callback('invalid query docmode: ' + qopts.docMode);\n\n      // The client tells us what versions it already has\n      qopts.versions = req.o.vs;\n\n      // Enables polling mode, which forces the query to be rerun on the whole\n      // index, not just the edited document.\n      qopts.poll = req.o.p;\n\n      // Set the backend for the request (useful if you have a SOLR index or something)\n      qopts.backend = req.o.b;\n    }\n  } else if (req.a !== 'bs') {\n    var collection = req.c;\n    var docName = req.d;\n  }\n\n  var self = this;\n  var agent = this.agent;\n\n  // Now process the actual message.\n  switch (req.a) {\n    case 'fetch':\n      // Fetch request.\n      if (req.v != null) {\n        // It says fetch on the tin, but if a version is specified the client\n        // actually wants me to fetch some ops.\n        agent.getOps(collection, docName, req.v, null, function(err, results) {\n          if (err) return callback(err);\n\n          for (var i = 0; i < results.length; i++) {\n            self._sendOp(collection, docName, results[i]);\n          }\n\n          callback(null, {});\n        });\n      } else {\n        // Fetch a snapshot.\n        agent.fetch(collection, docName, function(err, data) {\n          if (err) return callback(err);\n\n          callback(null, {data: data});\n        });\n      }\n      break;\n\n    case 'sub':\n      // Subscribe to a document. If the version is specified, we'll catch the\n      // client up by sending all ops since the specified version.\n      //\n      // If the version is not specified, the client doesn't have a snapshot\n      // yet. We'll send them a snapshot at the most recent version and stream\n      // operations from that version.\n      this._subscribe(collection, docName, req.v, function(err, data) {\n        if (err)\n          callback(err);\n        else\n          callback(null, {data:data});\n      });\n      break;\n\n    case 'bs':\n      this.bulkSubscribe(req.s, function(err, response) {\n        callback(err, err ? null : {s:response});\n      });\n      break;\n\n    case 'unsub':\n      // Unsubscribe from the specified document. This cancels the active\n      // opstream or an inflight subscribing state\n      this._setSubscribed(collection, docName, false);\n      callback(null, {});\n      break;\n\n    case 'op':\n      // Submit an operation.\n      //\n      // Shallow clone to get just the op data parts.\n      var opData = {\n        // src can be provided if it is not the same as the current session,\n        // such as a resubmission after a reconnect, but it usually isn't needed\n        src: req.src || agent.sessionId,\n        seq: req.seq,\n        v: req.v\n      };\n      if (req.op) opData.op = req.op;\n      if (req.create) opData.create = req.create;\n      if (req.del) opData.del = req.del;\n\n      // There's nothing to put in here yet. We might end up with some stuff\n      // from the client.\n      var options = {};\n\n      // Actually submit the op to the backend\n      agent.submit(collection, docName, opData, options, function(err, v, ops) {\n        // Occassional 'Op already submitted' errors are expected to happen\n        // as part of normal operation, since inflight ops need to be resent\n        // after disconnect\n        if (err) {\n          console.error('Op error:', err, collection, docName, opData, options);\n          if (err === 'Op already submitted') {\n            self._sendOp(collection, docName, opData);\n          }\n          callback(null, {a: 'ack', error: err});\n          return;\n        }\n\n        // The backend replies with any operations that the client is missing.\n        // If the client is subscribed to the document, it'll get those\n        // operations through the regular subscription channel. If the client\n        // isn't subscribed, we'll send the ops with the response as if it was\n        // subscribed so the client catches up.\n        if (!self._isSubscribed(collection, docName)) {\n          for (var i = 0; i < ops.length; i++) {\n            var op = ops[i];\n            if (!op) {\n              console.warn('Null op ignored in agent.submit callback.', collection, docName, opData, v, ops);\n              continue;\n            }\n            self._sendOp(collection, docName, op);\n          }\n          // Luckily, the op is transformed & etc in place.\n          self._sendOp(collection, docName, opData);\n        }\n        callback(null, {a: 'ack'});\n      });\n      break;\n\n\n    // ********* Queries **********\n\n    case 'qfetch':\n      // Fetch the results of a query. This does not subscribe to the query or\n      // anything, its just a once-off query fetch.\n      agent.queryFetch(index, req.q, qopts, function(err, results, extra) {\n        if (err) return callback(err);\n\n        // If the query subscribes to documents, the callback isn't called\n        // until all the documents are subscribed.\n        var data = self._processQueryResults(req.c, results, qopts);\n\n        callback(null, {id:qid, data:data, extra:extra});\n        //self._reply(req, null, {id:qid, data:results, extra:extra});\n      });\n      break;\n\n    case 'qsub':\n      // Subscribe to a query. The client is sent the query results and its\n      // notified whenever there's a change.\n      agent.query(index, req.q, qopts, function(err, emitter, results, extra) {\n        if (err) return callback(err);\n        if (self.queries[qid]) {\n          emitter.destroy();\n          return callback('ID in use');\n        }\n        if (self.closed) return emitter.destroy();\n\n        // `emitter` is a QueryEmitter passed through from LiveDB that emits\n        // events whenever the results change. Livedb is responsible for\n        // rerunning queries in the most efficient (or most expedient) manner.\n        self.queries[qid] = emitter;\n\n        emitter.onExtra = function(extra) {\n          self._send({a: 'q', id: qid, extra: extra});\n        };\n\n        // Note that only the docMode and not the full qopts is used, since\n        // qopts has the doc versions for the original subscription, and this\n        // emitter is sending an update from an ongoing subscription\n        var insertQueryOptions = {docMode: qopts.docMode};\n        emitter.onDiff = function(diff) {\n          for (var i = 0; i < diff.length; i++) {\n            var d = diff[i];\n            if (d.type === 'insert') {\n              d.values = self._processQueryResults(req.c, d.values, insertQueryOptions);\n            }\n          }\n\n          // Consider stripping the collection out of the data we send here\n          // if it matches the query's index.\n          self._send({a:'q', id:qid, diff:diff});\n        };\n\n        emitter.onError = function(err) {\n          // Should we destroy the emitter here?\n          self._send({a:'q', id:qid, error:err});\n          console.warn('Query ' + index + '.' + JSON.stringify(req.q) + ' emitted an error:', err);\n          emitter.destroy();\n          delete self.queries[qid];\n        };\n\n        emitter.onOp = function(data) {\n          var collection = data.collection;\n          var docName = data.docName;\n          // No need to send from the query if the doc is also subscribed\n          if (self._isSubscribed(collection, docName)) return;\n          // ShareJS filter middleware that might be doing access control or something\n          agent.filterOp(collection, docName, data, function(err, filtered) {\n            if (err) return emitter.onError(err);\n            self._sendOp(collection, docName, filtered);\n          });\n        };\n\n        var data = self._processQueryResults(req.c, results, qopts);\n        callback(null, {id: qid, data: data, extra: extra});\n      });\n      break;\n\n    case 'qunsub':\n      // Unsubscribe from a query.\n      var emitter = self.queries[qid];\n      if (emitter) {\n        emitter.destroy();\n        delete self.queries[qid];\n      }\n      callback();\n      break;\n\n    default:\n      console.warn('invalid message', req);\n      callback('invalid or unknown message');\n  }\n};\n\n// For debugging, this returns information on how many documents & queries are currently subscribed.\nSession.prototype.subscribeStats = function() {\n  var stats = {};\n\n  for (var c in this.collections) {\n    var count = 0;\n\n    for (var d in this.collections[c]) {\n      if (this.collections[c][d]) count++;\n    }\n\n    stats[c] = count;\n  }\n\n  return stats;\n};\n\nfunction hasKeys(object) {\n  for (var key in object) return true;\n  return false;\n}\n\n// Destroy a linked list of streams\nfunction destroyStream(opstream) {\n  opstream.destroy();\n  opstream.removeAllListeners('data');\n}\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/server/useragent.js":"var hat = require('hat');\nvar TransformStream = require('stream').Transform;\nvar async = require('async');\n\n\n/**\n * Provides access to the backend of `instance`.\n *\n * Create a user agent accessing a share instance\n *\n *   userAgent = new UserAgent(instance)\n *\n * The user agent exposes the following API to communicate asynchronously with\n * the share instances backend.\n * - submit (submit)\n * - fetch (fetch)\n * - subscribe (subscribe)\n * - getOps (get ops)\n * - query (query)\n * - queryFetch (query)\n *\n *\n * Middleware\n * ----------\n * Each of the API methods also triggers an action (given in brackets) on the\n * share instance. This enables middleware to modifiy the requests and results\n * By default the request passed to the middleware contains the properties\n * - action\n * - agent\n * - backend\n * - collection\n * - docName\n * The `collection` and `docName` properties are only set if applicable. In\n * addition each API method extends the request object with custom properties.\n * These are documented with the methods.\n *\n *\n * Filters\n * -------\n * The documents provided by the `fetch`, `query` and `queryFetch` methods are\n * filtered with the share instance's `docFilters`.\n *\n *   instance.filter(function(collection, docName, docData, next) {\n *     if (docName == \"mario\") {\n *       docData.greeting = \"It'se me: Mario\";\n *       next();\n *     } else {\n *       next(\"Document not found!\");\n *     }\n *   });\n *   userAgent.fetch('people', 'mario', function(error, data) {\n *     data.greeting; // It'se me\n *   });\n *   userAgent.fetch('people', 'peaches', function(error, data) {\n *     error == \"Document not found!\";\n *   });\n *\n * In a filter `this` is the user agent.\n *\n * Similarily we can filter the operations that a client can see\n *\n *   instance.filterOps(function(collection, docName, opData, next) {\n *     if (opData.op == 'cheat')\n *       next(\"Not on my watch!\");\n *     else\n *       next();\n *     }\n *   });\n *\n */\nvar UserAgent = function(instance, stream) {\n  this.instance = instance;\n  this.backend = instance.backend;\n\n  this.stream = stream;\n  this.sessionId = hat();\n\n  this.connectTime = new Date();\n};\n\nmodule.exports = UserAgent;\n\n/**\n * Helper to run the filters over some data. Returns an error string on error,\n * or nothing on success.  Data is modified in place.\n */\nUserAgent.prototype._runFilters = function(filters, collection, docName, data, callback) {\n  var self = this;\n  async.eachSeries(filters, function(filter, next) {\n    filter.call(self, collection, docName, data, next);\n  }, function(error) {\n    callback(error, error ? null : data);\n  });\n};\n\nUserAgent.prototype.filterDoc = function(collection, docName, data, callback) {\n  return this._runFilters(this.instance.docFilters, collection, docName, data, callback);\n};\nUserAgent.prototype.filterOp = function(collection, docName, data, callback) {\n  return this._runFilters(this.instance.opFilters, collection, docName, data, callback);\n};\n\n// This is only used by bulkFetch, but its enough logic that I prefer to\n// separate it out.\n//\n// data is a map from collection name -> doc name -> data.\nUserAgent.prototype.filterDocs = function(data, callback) {\n  var work = 1;\n  var done = function() {\n    work--;\n    if (work === 0 && callback) callback(null, data);\n  }\n\n  for (var cName in data) {\n    for (var docName in data[cName]) {\n      work++;\n      this.filterDoc(cName, docName, data[cName][docName], function(err) {\n        if (err && callback) {\n          callback(err);\n          callback = null;\n        }\n        // Clean up call stack\n        process.nextTick(done);\n      });\n    }\n  }\n  done();\n};\n\nUserAgent.prototype.filterOps = function(collection, docName, ops, callback) {\n  if (!ops) return callback();\n  var agent = this;\n  var i = 0;\n  (function next(err) {\n    if (err) return callback(err);\n    var op = ops[i++];\n    if (op) {\n      // Clean up call stack. Would it be better to modulus the iterator and\n      // only introduce next tick every nth iteration?\n      process.nextTick(function() {\n        agent.filterOp(collection, docName, op, next);\n      });\n    } else {\n      callback(null, ops);\n    }\n  })();\n};\n\n/**\n * Builds a request, passes it through the instance's extension stack for the\n * action and calls callback with the request.\n */\nUserAgent.prototype.trigger = function(action, collection, docName, request, callback) {\n  if (typeof request === 'function') {\n    callback = request;\n    request = {};\n  }\n\n  request.agent = this;\n  request.action = action;\n  if (collection) request.collection = collection;\n  if (docName) request.docName = docName;\n  request.backend = this.backend;\n\n  this.instance._trigger(request, callback);\n};\n\n\n/**\n * Fetch current snapshot of a document\n *\n * Triggers the `fetch` action. The actual fetch is performed with collection\n * and docName from the middleware request.\n */\nUserAgent.prototype.fetch = function(collection, docName, callback) {\n  var agent = this;\n\n  agent.trigger('fetch', collection, docName, function(err, action) {\n    if (err) return callback(err);\n    collection = action.collection;\n    docName = action.docName;\n\n    agent.backend.fetch(collection, docName, function(err, data) {\n      if (err) return callback(err);\n      if (data) {\n        agent.filterDoc(collection, docName, data, callback);\n      } else {\n        callback(null, data);\n      }\n    });\n  });\n};\n\nvar bulkFetchRequestsEmpty = function(requests) {\n  for (var cName in requests) {\n    if (requests[cName].length) return false;\n  }\n  return true;\n};\n\n// requests is a map from collection -> [docName]\nUserAgent.prototype.bulkFetch = function(requests, callback) {\n  var agent = this;\n\n  if (bulkFetchRequestsEmpty(requests)) return callback(null, {});\n\n  if (this.instance._hasMiddleware('bulk fetch') || !this.instance._hasMiddleware('fetch')) {\n    agent.trigger('bulk fetch', null, null, {requests:requests}, function(err, action) {\n      if (err) return callback(err);\n      requests = action.requests;\n\n      agent.backend.bulkFetch(requests, function(err, data) {\n        if (err) return callback(err);\n\n        agent.filterDocs(data, callback);\n      });\n    });\n  } else {\n    // Could implement this using async...\n    throw Error('If you have fetch middleware you need to also make bulk fetch middleware');\n  }\n};\n\n\n/**\n * Get all operations on this document with version in [start, end).\n *\n * Tiggers `get ops` action with requst\n *   { start: start, end: end }\n */\nUserAgent.prototype.getOps = function(collection, docName, start, end, callback) {\n  var agent = this;\n\n  agent.trigger('get ops', collection, docName, {start:start, end:end}, function(err, action) {\n    if (err) return callback(err);\n\n    agent.backend.getOps(action.collection, action.docName, start, end, function(err, results) {\n      if (err) return callback(err);\n\n      agent.filterOps(collection, docName, results, callback);\n    });\n  });\n};\n\nfunction OpTransformStream(agent, collection, docName, stream) {\n  TransformStream.call(this, {objectMode: true});\n  this.agent = agent;\n  this.collection = collection;\n  this.docName = docName;\n  this.stream = stream;\n}\n\nOpTransformStream.prototype = Object.create(TransformStream.prototype);\n\nOpTransformStream.prototype.destroy = function() {\n  this.stream.destroy();\n};\n\nOpTransformStream.prototype._transform = function(data, encoding, callback) {\n  var filterOpCallback = getFilterOpCallback(this, callback);\n  this.agent.filterOp(this.collection, this.docName, data, filterOpCallback);\n};\n\nfunction getFilterOpCallback(opTransformStream, callback) {\n  return function filterOpCallback(err, data) {\n    opTransformStream.push(err ? {error: err} : data);\n    callback();\n  };\n}\n\n/**\n * Filter the data passed through the stream with `filterOp()`\n *\n * Returns a new stream that let's us only read these messages from stream wich\n * where not filtered by `this.filterOp(collection, docName, message)`. If the\n * filter chain calls an error we read a `{error: 'description'}` message from the\n * stream.\n */\nUserAgent.prototype.wrapOpStream = function(collection, docName, stream) {\n  var opTransformStream = new OpTransformStream(this, collection, docName, stream);\n  stream.pipe(opTransformStream);\n  return opTransformStream;\n};\n\n\n/**\n * Apply `wrapOpStream()` to each stream\n *\n * `streams` is a map `collection -> docName -> stream`. It returns the same map\n * with the streams wrapped.\n */\nUserAgent.prototype.wrapOpStreams = function(streams) {\n  for (var cName in streams) {\n    for (var docName in streams[cName]) {\n      streams[cName][docName] = this.wrapOpStream(cName, docName, streams[cName][docName]);\n    }\n  }\n  return streams;\n};\n\n\n/**\n * Get stream of operations for a document.\n *\n * On success it resturns a readable stream of operations for this document.\n *\n * Triggers the `subscribe` action with request\n *   { version: version }\n */\nUserAgent.prototype.subscribe = function(collection, docName, version, callback) {\n  var agent = this;\n  agent.trigger('subscribe', collection, docName, {version:version}, function(err, action) {\n    if (err) return callback(err);\n    collection = action.collection;\n    docName = action.docName;\n    version = action.version;\n    agent.backend.subscribe(collection, docName, version, function(err, stream) {\n       callback(err, err ? null : agent.wrapOpStream(collection, docName, stream));\n    });\n  });\n};\n\n// requests is a map from cName -> docName -> version.\nUserAgent.prototype.bulkSubscribe = function(requests, callback) {\n  var agent = this;\n  // Use a bulk subscribe to check everything in one go.\n  agent.trigger('bulk subscribe', null, null, {requests: requests}, function(err, action) {\n    if (err) return callback(err);\n    agent.backend.bulkSubscribe(action.requests, function(err, streams) {\n      callback(err, err ? null : agent.wrapOpStreams(streams));\n    });\n  });\n};\n\n\n// DEPRECATED - just call fetch() then subscribe() yourself.\nUserAgent.prototype.fetchAndSubscribe = function(collection, docName, callback) {\n  var agent = this;\n  agent.trigger('fetch', collection, docName, function(err, action) {\n    if (err) return callback(err);\n    agent.trigger('subscribe', action.collection, action.docName, function(err, action) {\n      if (err) return callback(err);\n\n      collection = action.collection;\n      docName = action.docName;\n      agent.backend.fetchAndSubscribe(action.collection, action.docName, function(err, data, stream) {\n        if (err) return callback(err);\n        agent.filterDoc(collection, docName, data, function (err, data) {\n          if (err) return callback(err);\n          var wrappedStream = agent.wrapOpStream(collection, docName, stream);\n          callback(null, data, wrappedStream);\n        });\n      });\n    });\n  });\n};\n\n\n/**\n * Submits an operation.\n *\n * On success it returns the version and the operation.\n *\n * Triggers the `submit` action with request\n *   { opData: opData, channelPrefix: null }\n * and the `after submit` action with the request\n *   { opData: opData, snapshot: modifiedSnapshot }\n */\nUserAgent.prototype.submit = function(collection, docName, opData, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var agent = this;\n  agent.trigger('submit', collection, docName, {opData: opData, channelPrefix:null}, function(err, action) {\n    if (err) return callback(err);\n\n    collection = action.collection;\n    docName = action.docName;\n    opData = action.opData;\n    options.channelPrefix = action.channelPrefix;\n\n    if (!opData.preValidate) opData.preValidate = agent.instance.preValidate;\n    if (!opData.validate) opData.validate = agent.instance.validate;\n\n    agent.backend.submit(collection, docName, opData, options, function(err, v, ops, snapshot) {\n      if (err) return callback(err);\n      agent.trigger('after submit', collection, docName, {opData: opData, snapshot: snapshot}, function(err) {\n        if (err) return callback(err);\n        agent.filterOps(collection, docName, ops, function(err, filteredOps) {\n          if (err) return callback(err);\n          callback(null, v, filteredOps);\n        });\n      });\n    });\n  });\n};\n\n/** Helper to filter query result sets */\nUserAgent.prototype._filterQueryResults = function(collection, results, callback) {\n  // The filter function is asyncronous. We can run all of the query results in parallel.\n  var agent = this;\n  async.each(results, function(data, innerCb) {\n    agent.filterDoc(collection, data.docName, data, innerCb);\n  }, function(error) {\n    callback(error, results);\n  });\n};\n\n\n/**\n * Execute a query and fetch matching documents.\n *\n * The result is an array of the matching documents. Each document has in\n * addtion the `docName` property set to its name.\n *\n * Triggers the `query` action with the request\n *   { query: query, fetch: true, options: options }\n */\nUserAgent.prototype.queryFetch = function(collection, query, options, callback) {\n  var agent = this;\n  // Should we emit 'query' or 'query fetch' here?\n  agent.trigger('query', collection, null, {query:query, fetch:true, options: options}, function(err, action) {\n    if (err) return callback(err);\n\n    collection = action.collection;\n    query = action.query;\n\n    agent.backend.queryFetch(collection, query, options, function(err, results, extra) {\n      if (err) return callback(err);\n      agent._filterQueryResults(collection, results, function(err, results) {\n        if (err) return callback(err);\n        callback(null, results, extra);\n      });\n    });\n  });\n};\n\n\n/**\n * Get an QueryEmitter for the query\n *\n * The returned emitter fires 'diff' event every time the result of the query\n * changes.\n *\n * Triggers the `query` action with the request\n *   { query: query, options: options }\n */\nUserAgent.prototype.query = function(collection, query, options, callback) {\n  var agent = this;\n  agent.trigger('query', collection, null, {query: query, options: options}, function(err, action) {\n    if (err) return callback(err);\n\n    collection = action.collection;\n    query = action.query;\n\n    agent.backend.query(collection, query, options, function(err, emitter, results, extra) {\n      if (err) return callback(err);\n\n      // Override emitDiff to filter all inserted items\n      emitter.emitDiff = function(diff) {\n        async.each(diff, function(item, cb) {\n          if (item.type === 'insert') {\n            agent._filterQueryResults(collection, item.values, cb);\n            return;\n          }\n          cb();\n        }, function(err) {\n          if (err) return emitter.emitError(err);\n          emitter.onDiff(diff);\n        });\n      };\n\n      // TODO: This is buggy. If the emitter emits a diff during a slow piece of\n      // middleware, it'll be lost.\n      agent._filterQueryResults(collection, results, function(err, results) {\n        // Also if there's an error here, the emitter is never removed.\n        if (err) return callback(err);\n        callback(null, emitter, results, extra);\n      });\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/client/index.js":"// Entry point for the client\n//\n// Usage:\n//\n//    <script src=\"dist/share.js\"></script>\n\nexports.Connection = require('./connection').Connection;\nexports.Doc = require('./doc').Doc;\nrequire('./textarea');\n\nvar types = require('../types');\nexports.ottypes = types.ottypes;\nexports.registerType = types.registerType;\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/client/connection.js":"var Doc = require('./doc').Doc;\nvar Query = require('./query').Query;\nvar emitter = require('./emitter');\n\n\n/**\n * Handles communication with the sharejs server and provides queries and\n * documents.\n *\n * We create a connection with a socket object\n *   connection = new sharejs.Connection(sockset)\n * The socket may be any object handling the websocket protocol. See the\n * documentation of bindToSocket() for details. We then wait for the connection\n * to connect\n *   connection.on('connected', ...)\n * and are finally able to work with shared documents\n *   connection.get('food', 'steak') // Doc\n *\n * @param socket @see bindToSocket\n */\nvar Connection = exports.Connection = function (socket) {\n  emitter.EventEmitter.call(this);\n\n  // Map of collection -> docName -> doc object for created documents.\n  // (created documents MUST BE UNIQUE)\n  this.collections = {};\n\n  // Each query is created with an id that the server uses when it sends us\n  // info about the query (updates, etc).\n  //this.nextQueryId = (Math.random() * 1000) |0;\n  this.nextQueryId = 1;\n\n  // Map from query ID -> query object.\n  this.queries = {};\n\n  // State of the connection. The correspoding events are emmited when this\n  // changes. Available states are:\n  // - 'connecting'   The connection has been established, but we don't have our\n  //                  client ID yet\n  // - 'connected'    We have connected and recieved our client ID. Ready for data.\n  // - 'disconnected' The connection is closed, but it will reconnect automatically.\n  // - 'stopped'      The connection is closed, and should not reconnect.\n  this.state = 'disconnected';\n\n  // This is a helper variable the document uses to see whether we're currently\n  // in a 'live' state. It is true if we're connected, or if you're using\n  // browserchannel and connecting.\n  this.canSend = false;\n\n  // Private variable to support clearing of op retry interval\n  this._retryInterval = null;\n\n  // Reset some more state variables.\n  this.reset();\n\n  this.debug = false;\n\n  // I'll store the most recent 100 messages so when errors occur we can see\n  // what happened.\n  this.messageBuffer = [];\n\n  this.bindToSocket(socket);\n}\nemitter.mixin(Connection);\n\n\n/**\n * Use socket to communicate with server\n *\n * Socket is an object that can handle the websocket protocol. This method\n * installs the onopen, onclose, onmessage and onerror handlers on the socket to\n * handle communication and sends messages by calling socket.send(msg). The\n * sockets `readyState` property is used to determine the initaial state.\n *\n * @param socket Handles the websocket protocol\n * @param socket.readyState\n * @param socket.close\n * @param socket.send\n * @param socket.onopen\n * @param socket.onclose\n * @param socket.onmessage\n * @param socket.onerror\n */\nConnection.prototype.bindToSocket = function(socket) {\n  if (this.socket) {\n    delete this.socket.onopen\n    delete this.socket.onclose\n    delete this.socket.onmessage\n    delete this.socket.onerror\n  }\n\n  // TODO: Check that the socket is in the 'connecting' state.\n\n  this.socket = socket;\n  // This logic is replicated in setState - consider calling setState here\n  // instead.\n  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';\n  this.canSend = this.state === 'connecting' && socket.canSendWhileConnecting;\n  this._setupRetry();\n\n  var connection = this\n\n  socket.onmessage = function(msg) {\n    var data = msg.data;\n\n    // Fall back to supporting old browserchannel 1.x API which implemented the\n    // websocket API incorrectly. This will be removed at some point\n    if (!data) data = msg;\n\n    // Some transports don't need parsing.\n    if (typeof data === 'string') data = JSON.parse(data);\n\n    if (connection.debug) console.log('RECV', JSON.stringify(data));\n\n    connection.messageBuffer.push({\n      t: (new Date()).toTimeString(),\n      recv:JSON.stringify(data)\n    });\n    while (connection.messageBuffer.length > 100) {\n      connection.messageBuffer.shift();\n    }\n\n    try {\n      connection.handleMessage(data);\n    } catch (err) {\n      connection.emit('error', err, data);\n      // We could also restart the connection here, although that might result\n      // in infinite reconnection bugs.\n    }\n  }\n\n  socket.onopen = function() {\n    connection._setState('connecting');\n  };\n\n  socket.onerror = function(e) {\n    // This isn't the same as a regular error, because it will happen normally\n    // from time to time. Your connection should probably automatically\n    // reconnect anyway, but that should be triggered off onclose not onerror.\n    // (onclose happens when onerror gets called anyway).\n    connection.emit('connection error', e);\n  };\n\n  socket.onclose = function(reason) {\n    // reason values:\n    //   'Closed' - The socket was manually closed by calling socket.close()\n    //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting\n    //   'Request failed' - Server didn't respond to request (temporary, usually offline)\n    //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)\n    connection._setState('disconnected', reason);\n    if (reason === 'Closed' || reason === 'Stopped by server') {\n      connection._setState('stopped', reason);\n    }\n  };\n};\n\n\n/**\n * @param {object} msg\n * @param {String} msg.a action\n */\nConnection.prototype.handleMessage = function(msg) {\n  // Switch on the message action. Most messages are for documents and are\n  // handled in the doc class.\n  switch (msg.a) {\n    case 'init':\n      // Client initialization packet. This bundle of joy contains our client\n      // ID.\n      if (msg.protocol !== 0) throw new Error('Invalid protocol version');\n      if (typeof msg.id != 'string') throw new Error('Invalid client id');\n\n      this.id = msg.id;\n      this._setState('connected');\n      break;\n\n    case 'qfetch':\n    case 'qsub':\n    case 'q':\n    case 'qunsub':\n      // Query message. Pass this to the appropriate query object.\n      var query = this.queries[msg.id];\n      if (query) query._onMessage(msg);\n      break;\n\n    case 'bs':\n      // Bulk subscribe response. The responses for each document are contained within.\n      var result = msg.s;\n      for (var cName in result) {\n        for (var docName in result[cName]) {\n          var doc = this.get(cName, docName);\n          if (!doc) {\n            console.warn('Message for unknown doc. Ignoring.', msg);\n            break;\n          }\n\n          var msg = result[cName][docName];\n          if (typeof msg === 'object') {\n            doc._handleSubscribe(msg.error, msg);\n          } else {\n            // The msg will be true if we simply resubscribed.\n            doc._handleSubscribe(null, null);\n          }\n        }\n      }\n      break;\n\n    default:\n      // Document message. Pull out the referenced document and forward the\n      // message.\n      var doc = this.getExisting(msg.c, msg.d);\n      if (doc) doc._onMessage(msg);\n  }\n};\n\n\nConnection.prototype.reset = function() {\n  this.id = null;\n  this.seq = 1;\n};\n\n\nConnection.prototype._setupRetry = function() {\n  if (!this.canSend) {\n    clearInterval(this._retryInterval);\n    this._retryInterval = null;\n    return;\n  }\n  if (this._retryInterval != null) return;\n\n  var connection = this;\n  this._retryInterval = setInterval(function() {\n    for (var collectionName in connection.collections) {\n      var collection = connection.collections[collectionName];\n      for (var docName in collection) {\n        collection[docName].retry();\n      }\n    }\n  }, 1000);\n};\n\n\n// Set the connection's state. The connection is basically a state machine.\nConnection.prototype._setState = function(newState, data) {\n  if (this.state === newState) return;\n\n  // I made a state diagram. The only invalid transitions are getting to\n  // 'connecting' from anywhere other than 'disconnected' and getting to\n  // 'connected' from anywhere other than 'connecting'.\n  if (\n    (newState === 'connecting' && this.state !== 'disconnected' && this.state !== 'stopped') ||\n    (newState === 'connected' && this.state !== 'connecting')\n  ) {\n    throw new Error(\"Cannot transition directly from \" + this.state + \" to \" + newState);\n  }\n\n  this.state = newState;\n  this.canSend =\n    (newState === 'connecting' && this.socket.canSendWhileConnecting) ||\n    (newState === 'connected');\n  this._setupRetry();\n\n  if (newState === 'disconnected') this.reset();\n\n  this.emit(newState, data);\n\n  // Group all subscribes together to help server make more efficient calls\n  this.bsStart();\n  // Emit the event to all queries\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    query._onConnectionStateChanged(newState, data);\n  }\n  // Emit the event to all documents\n  for (var c in this.collections) {\n    var collection = this.collections[c];\n    for (var docName in collection) {\n      collection[docName]._onConnectionStateChanged(newState, data);\n    }\n  }\n  this.bsEnd();\n};\n\nConnection.prototype.bsStart = function() {\n  this.subscribeData = this.subscribeData || {};\n};\n\nConnection.prototype.bsEnd = function() {\n  // Only send bulk subscribe if not empty\n  if (hasKeys(this.subscribeData)) {\n    this.send({a:'bs', s:this.subscribeData});\n  }\n  this.subscribeData = null;\n};\n\nConnection.prototype.sendSubscribe = function(doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  if (this.subscribeData) {\n    // Bulk subscribe\n    var data = this.subscribeData;\n    if (!data[doc.collection]) data[doc.collection] = {};\n    data[doc.collection][doc.name] = version || null;\n  } else {\n    // Send single subscribe message\n    var msg = {a: 'sub', c: doc.collection, d: doc.name};\n    if (version != null) msg.v = version;\n    this.send(msg);\n  }\n};\n\nConnection.prototype.sendFetch = function(doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var msg = {a: 'fetch', c: doc.collection, d: doc.name};\n  if (version != null) msg.v = version;\n  this.send(msg);\n};\n\nConnection.prototype.sendUnsubscribe = function(doc) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var msg = {a: 'unsub', c: doc.collection, d: doc.name};\n  this.send(msg);\n};\n\nConnection.prototype.sendOp = function(doc, data) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var msg = {\n    a: 'op',\n    c: doc.collection,\n    d: doc.name,\n    v: doc.version,\n    src: data.src,\n    seq: data.seq\n  };\n  if (data.op) msg.op = data.op;\n  if (data.create) msg.create = data.create;\n  if (data.del) msg.del = data.del;\n  this.send(msg);\n};\n\n\n/**\n * Sends a message down the socket\n */\nConnection.prototype.send = function(msg) {\n  if (this.debug) console.log(\"SEND\", JSON.stringify(msg));\n\n  this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});\n  while (this.messageBuffer.length > 100) {\n    this.messageBuffer.shift();\n  }\n\n  if (!this.socket.canSendJSON) {\n    msg = JSON.stringify(msg);\n  }\n  this.socket.send(msg);\n};\n\n\n/**\n * Closes the socket and emits 'disconnected'\n */\nConnection.prototype.disconnect = function() {\n  this.socket.close();\n};\n\nConnection.prototype.getExisting = function(collection, name) {\n  if (this.collections[collection]) return this.collections[collection][name];\n};\n\n\n/**\n * @deprecated\n */\nConnection.prototype.getOrCreate = function(collection, name, data) {\n  console.trace('getOrCreate is deprecated. Use get() instead');\n  return this.get(collection, name, data);\n};\n\n\n/**\n * Get or create a document.\n *\n * @param collection\n * @param name\n * @param [data] ingested into document if created\n * @return {Doc}\n */\nConnection.prototype.get = function(collection, name, data) {\n  var collectionObject = this.collections[collection];\n  if (!collectionObject)\n    collectionObject = this.collections[collection] = {};\n\n  var doc = collectionObject[name];\n  if (!doc) {\n    doc = collectionObject[name] = new Doc(this, collection, name);\n    this.emit('doc', doc);\n  }\n\n  // Even if the document isn't new, its possible the document was created\n  // manually and then tried to be re-created with data (suppose a query\n  // returns with data for the document). We should hydrate the document\n  // immediately if we can because the query callback will expect the document\n  // to have data.\n  if (data && data.data !== undefined && !doc.state) {\n    doc.ingestData(data);\n  }\n\n  return doc;\n};\n\n\n/**\n * Remove document from this.collections\n *\n * @private\n */\nConnection.prototype._destroyDoc = function(doc) {\n  var collectionObject = this.collections[doc.collection];\n  if (!collectionObject) return;\n\n  delete collectionObject[doc.name];\n\n  // Delete the collection container if its empty. This could be a source of\n  // memory leaks if you slowly make a billion collections, which you probably\n  // won't do anyway, but whatever.\n  if (!hasKeys(collectionObject))\n    delete this.collections[doc.collection];\n};\n\nConnection.prototype._addDoc = function(doc) {\n  var collectionObject = this.collections[doc.collection];\n  if (!collectionObject) {\n    collectionObject = this.collections[doc.collection] = {};\n  }\n  if (collectionObject[doc.name] !== doc) {\n    collectionObject[doc.name] = doc;\n  }\n};\n\n\nfunction hasKeys(object) {\n  for (var key in object) return true;\n  return false;\n};\n\n\n// Helper for createFetchQuery and createSubscribeQuery, below.\nConnection.prototype._createQuery = function(type, collection, q, options, callback) {\n  if (type !== 'fetch' && type !== 'sub')\n    throw new Error('Invalid query type: ' + type);\n\n  if (!options) options = {};\n  var id = this.nextQueryId++;\n  var query = new Query(type, this, id, collection, q, options, callback);\n  this.queries[id] = query;\n  query._execute();\n  return query;\n};\n\n// Internal function. Use query.destroy() to remove queries.\nConnection.prototype._destroyQuery = function(query) {\n  delete this.queries[query.id];\n};\n\n// The query options object can contain the following fields:\n//\n// docMode: What to do with documents that are in the result set. Can be\n//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates\n//   that the server should send document snapshots to the client for all query\n//   results. These will be hydrated into the document objects before the query\n//   result callbacks are returned. Subscribe mode gets document snapshots and\n//   automatically subscribes the client to all results. Note that the\n//   documents *WILL NOT* be automatically unsubscribed when the query is\n//   destroyed. (ShareJS doesn't have enough information to do that safely).\n//   Beware of memory leaks when using this option.\n//\n// poll: Forcably enable or disable polling mode. Polling mode will reissue the query\n//   every time anything in the collection changes (!!) so, its quite\n//   expensive.  It is automatically enabled for paginated and sorted queries.\n//   By default queries run with polling mode disabled; which will only check\n//   changed documents to test if they now match the specified query.\n//   Set to false to disable polling mode, or true to enable it. If you don't\n//   specify a poll option, polling mode is enabled or disabled automatically\n//   by the query's backend.\n//\n// backend: Set the backend source for the query. You can attach different\n//   query backends to livedb and pick which one the query should hit using\n//   this parameter.\n//\n// results: (experimental) Initial list of resultant documents. This is\n//   useful for rehydrating queries when you're using autoFetch / autoSubscribe\n//   so the server doesn't have to send over snapshots for documents the client\n//   already knows about. This is experimental - the API may change in upcoming\n//   versions.\n\n// Create a fetch query. Fetch queries are only issued once, returning the\n// results directly into the callback.\n//\n// The index is specific to the source, but if you're using mongodb it'll be\n// the collection to which the query is made.\n// The callback should have the signature function(error, results, extraData)\n// where results is a list of Doc objects.\nConnection.prototype.createFetchQuery = function(index, q, options, callback) {\n  return this._createQuery('fetch', index, q, options, callback);\n};\n\n// Create a subscribe query. Subscribe queries return with the initial data\n// through the callback, then update themselves whenever the query result set\n// changes via their own event emitter.\n//\n// If present, the callback should have the signature function(error, results, extraData)\n// where results is a list of Doc objects.\nConnection.prototype.createSubscribeQuery = function(index, q, options, callback) {\n  return this._createQuery('sub', index, q, options, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/client/doc.js":"var types = require('../types').ottypes;\nvar emitter = require('./emitter');\n\n/**\n * A Doc is a client's view on a sharejs document.\n *\n * It is is uniquely identified by its `name` and `collection`.  Documents\n * should not be created directly. Create them with Connection.get()\n *\n *\n *\n * Subscriptions\n * -------------\n *\n * We can subscribe a document to stay in sync with the server.\n *   doc.subscribe(function(error) {\n *     doc.state // = 'ready'\n *     doc.subscribed // = true\n *   })\n * The server now sends us all changes concerning this document and these are\n * applied to our snapshot. If the subscription was successful the initial\n * snapshot and version sent by the server are loaded into the document.\n *\n * To stop listening to the changes we call `doc.unsubscribe()`.\n *\n * If we just want to load the data but not stay up-to-date, we call\n *   doc.fetch(function(error) {\n *     doc.snapshot // sent by server\n *   })\n *\n * TODO What happens when the document does not exist yet.\n *\n *\n *\n * Editing documents\n * ------------------\n *\n * To edit a document we have to create an editing context\n *   context = doc.context()\n * The context is an object exposing the type API of the documents OT type.\n *   doc.type = 'text'\n *   context.insert(0, 'In the beginning')\n *   doc.snapshot // 'In the beginning...'\n *\n * If a operation is applied on the snapshot the `_onOp` on the context is\n * called. The type implementation then usually triggers a corresponding event.\n *\n *\n *\n *\n * Events\n * ------\n *\n * You can use doc.on(eventName, callback) to subscribe to the following events:\n * - `before op (op, localContext)` Fired before an operation is applied to the\n *   snapshot. The document is already in locked state, so it is not allowed to\n *   submit further operations. It may be used to read the old snapshot just\n *   before applying an operation. The callback is passed the operation and the\n *   editing context if the operation originated locally and `false` otherwise\n * - `after op (op, localContext)` Fired after an operation has been applied to\n *   the snapshot. The arguments are the same as for `before op`\n * - `op (op, localContext)` The same as `after op` unless incremental updates\n *   are enabled. In this case it is fired after every partial operation with\n *   this operation as the first argument. When fired the document is in a\n *   locked state which only allows reading operations.\n * - `subscribed (error)` The document was subscribed\n * - `created (localContext)` The document was created. That means its type was\n *   set and it has some initial data.\n * - `del (localContext, snapshot)` Fired after the document is deleted, that is\n *   the snapshot is null. It is passed the snapshot before delteion as an\n *   arguments\n * - `error`\n *\n * TODO rename `op` to `after partial op`\n */\nvar Doc = exports.Doc = function(connection, collection, name) {\n  emitter.EventEmitter.call(this);\n\n  this.connection = connection;\n\n  this.collection = collection;\n  this.name = name;\n\n  this.version = this.type = null;\n  this.snapshot = undefined;\n\n  // **** State in document:\n\n  // The action the document tries to perform with the server\n  //\n  // - subscribe\n  // - unsubscribe\n  // - fetch\n  // - submit: send an operation\n  this.action = null;\n\n  // The data the document object stores can be in one of the following three states:\n  //   - No data. (null) We honestly don't know whats going on.\n  //   - Floating ('floating'): we have a locally created document that hasn't\n  //     been created on the server yet)\n  //   - Live ('ready') (we have data thats current on the server at some version).\n  this.state = null;\n\n  // Our subscription status. Either we're subscribed on the server, or we aren't.\n  this.subscribed = false;\n  // Either we want to be subscribed (true), we want a new snapshot from the\n  // server ('fetch'), or we don't care (false). This is also used when we\n  // disconnect & reconnect to decide what to do.\n  this.wantSubscribe = false;\n  // This list is used for subscribe and unsubscribe, since we'll only want to\n  // do one thing at a time.\n  this._subscribeCallbacks = [];\n\n\n  // *** end state stuff.\n\n  // This doesn't provide any standard API access right now.\n  this.provides = {};\n\n  // The editing contexts. These are usually instances of the type API when the\n  // document is ready for edits.\n  this.editingContexts = [];\n\n  // The op that is currently roundtripping to the server, or null.\n  //\n  // When the connection reconnects, the inflight op is resubmitted.\n  //\n  // This has the same format as an entry in pendingData, which is:\n  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}\n  this.inflightData = null;\n\n  // All ops that are waiting for the server to acknowledge this.inflightData\n  // This used to just be a single operation, but creates & deletes can't be\n  // composed with regular operations.\n  //\n  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}\n  this.pendingData = [];\n\n  // The OT type of this document.\n  //\n  // The document also responds to the api provided by the type\n  this.type = null;\n\n  // For debouncing getLatestOps calls\n  this._getLatestTimeout = null;\n};\nemitter.mixin(Doc);\n\n/**\n * Unsubscribe and remove all editing contexts\n */\nDoc.prototype.destroy = function(callback) {\n  var doc = this;\n  this.unsubscribe(function() {\n    // Don't care if there's an error unsubscribing.\n\n    if (doc.hasPending()) {\n      doc.once('nothing pending', function() {\n        doc.connection._destroyDoc(doc);\n      });\n    } else {\n      doc.connection._destroyDoc(doc);\n    }\n    doc.removeContexts();\n    if (callback) callback();\n  });\n};\n\n\n// ****** Manipulating the document snapshot, version and type.\n\n// Set the document's type, and associated properties. Most of the logic in\n// this function exists to update the document based on any added & removed API\n// methods.\n//\n// @param newType OT type provided by the ottypes library or its name or uri\nDoc.prototype._setType = function(newType) {\n  if (typeof newType === 'string') {\n    if (!types[newType]) throw new Error(\"Missing type \" + newType + ' ' + this.collection + ' ' + this.name);\n    newType = types[newType];\n  }\n  this.removeContexts();\n\n  // Set the new type\n  this.type = newType;\n\n  // If we removed the type from the object, also remove its snapshot.\n  if (!newType) {\n    this.provides = {};\n    this.snapshot = undefined;\n  } else if (newType.api) {\n    // Register the new type's API.\n    this.provides = newType.api.provides;\n  }\n};\n\n// Injest snapshot data. This data must include a version, snapshot and type.\n// This is used both to ingest data that was exported with a webpage and data\n// that was received from the server during a fetch.\n//\n// @param data.v    version\n// @param data.data\n// @param data.type\n// @fires ready\nDoc.prototype.ingestData = function(data) {\n  if (typeof data.v !== 'number') {\n    throw new Error('Missing version in ingested data ' + this.collection + ' ' + this.name);\n  }\n  if (this.state) {\n    // Silently ignore if doc snapshot version is equal or newer\n    // TODO: Investigate whether this should happen in practice or not\n    if (this.version >= data.v) return;\n    console.warn('Ignoring ingest data for', this.collection, this.name,\n      '\\n  in state:', this.state, '\\n  version:', this.version,\n      '\\n  snapshot:\\n', this.snapshot, '\\n  incoming data:\\n', data);\n    return;\n  }\n\n  this.version = data.v;\n  // data.data is what the server will actually send. data.snapshot is the old\n  // field name - supported now for backwards compatibility.\n  this.snapshot = data.data;\n  this._setType(data.type);\n\n  this.state = 'ready';\n  this.emit('ready');\n};\n\n// Get and return the current document snapshot.\nDoc.prototype.getSnapshot = function() {\n  return this.snapshot;\n};\n\n// The callback will be called at a time when the document has a snapshot and\n// you can start applying operations. This may be immediately.\nDoc.prototype.whenReady = function(fn) {\n  if (this.state === 'ready') {\n    fn();\n  } else {\n    this.once('ready', fn);\n  }\n};\n\nDoc.prototype.hasPending = function() {\n  return this.action != null || this.inflightData != null || !!this.pendingData.length;\n};\n\nDoc.prototype._emitNothingPending = function() {\n  if (this.hasPending()) return;\n  this.emit('nothing pending');\n};\n\n\n// **** Helpers for network messages\n\n// This function exists so connection can call it directly for bulk subscribes.\n// It could just make a temporary object literal, thats pretty slow.\nDoc.prototype._handleSubscribe = function(err, data) {\n  if (err && err !== 'Already subscribed') {\n    console.error('Could not subscribe:', err, this.collection, this.name);\n    this.emit('error', err);\n    // There's probably a reason we couldn't subscribe. Don't retry.\n    this._setWantSubscribe(false, null, err);\n    return;\n  }\n  if (data) this.ingestData(data);\n  this.subscribed = true;\n  this._clearAction();\n  this.emit('subscribe');\n  this._finishSub();\n};\n\n// This is called by the connection when it receives a message for the document.\nDoc.prototype._onMessage = function(msg) {\n  if (!(msg.c === this.collection && msg.d === this.name)) {\n    // This should never happen - its a sanity check for bugs in the connection code.\n    var err = 'Got message for wrong document.';\n    console.error(err, this.collection, this.name, msg);\n    throw new Error(err);\n  }\n\n  // msg.a = the action.\n  switch (msg.a) {\n    case 'fetch':\n      // We're done fetching. This message has no other information.\n      if (msg.data) this.ingestData(msg.data);\n      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;\n      this._clearAction();\n      this._finishSub(msg.error);\n      break;\n\n    case 'sub':\n      // Subscribe reply.\n      this._handleSubscribe(msg.error, msg.data);\n      break;\n\n    case 'unsub':\n      // Unsubscribe reply\n      this.subscribed = false;\n      this.emit('unsubscribe');\n\n      this._clearAction();\n      this._finishSub(msg.error);\n      break;\n\n    case 'ack':\n      // Acknowledge a locally submitted operation.\n      //\n      // Usually we do nothing here - all the interesting logic happens when we\n      // get sent our op back in the op stream (which happens even if we aren't\n      // subscribed)\n      if (msg.error && msg.error !== 'Op already submitted') {\n        // The server has rejected an op from the client for an unexpected reason.\n        // We'll send the error message to the user and try to roll back the change.\n        if (this.inflightData) {\n          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');\n          this._tryRollback(this.inflightData);\n          this._clearInflightOp(msg.error);\n        } else {\n          // I managed to get into this state once. I'm not sure how it happened.\n          // The op was maybe double-acknowledged?\n          console.warn('Second acknowledgement message (error) received', msg, this);\n        }\n      }\n      break;\n\n    case 'op':\n      if (this.inflightData &&\n          msg.src === this.inflightData.src &&\n          msg.seq === this.inflightData.seq) {\n        // This one is mine. Accept it as acknowledged.\n        this._opAcknowledged(msg);\n        break;\n      }\n\n      if (this.version == null || msg.v > this.version) {\n        // This will happen in normal operation if we become subscribed to a\n        // new document via a query. It can also happen if we get an op for\n        // a future version beyond the version we are expecting next. This\n        // could happen if the server doesn't publish an op for whatever reason\n        // or because of a race condition. In any case, we can send a fetch\n        // command to catch back up.\n        this._getLatestOps();\n        break;\n      }\n\n      if (msg.v < this.version) {\n        // This will happen naturally in the following (or similar) cases:\n        //\n        // Client is not subscribed to document.\n        // -> client submits an operation (v=10)\n        // -> client subscribes to a query which matches this document. Says we\n        //    have v=10 of the doc.\n        //\n        // <- server acknowledges the operation (v=11). Server acknowledges the\n        //    operation because the doc isn't subscribed\n        // <- server processes the query, which says the client only has v=10.\n        //    Server subscribes at v=10 not v=11, so we get another copy of the\n        //    v=10 operation.\n        //\n        // In this case, we can safely ignore the old (duplicate) operation.\n        break;\n      }\n\n      if (this.inflightData) xf(this.inflightData, msg);\n\n      for (var i = 0; i < this.pendingData.length; i++) {\n        xf(this.pendingData[i], msg);\n      }\n\n      this.version++;\n      this._otApply(msg, false);\n      break;\n\n    case 'meta':\n      console.warn('Unhandled meta op:', msg);\n      break;\n\n    default:\n      console.warn('Unhandled document message:', msg);\n      break;\n  }\n};\n\nDoc.prototype._getLatestOps = function() {\n  var doc = this;\n  var debounced = false;\n  if (doc._getLatestTimeout) {\n    debounced = true;\n  } else {\n    // Send a fetch command, which will get us the missing ops to catch back up\n    // or the full doc if our version is currently null\n    doc.connection.sendFetch(doc, doc.version);\n  }\n  // Debounce calls, since we are likely to get multiple future operations\n  // in a rapid sequence\n  clearTimeout(doc._getLatestTimeout);\n  doc._getLatestTimeout = setTimeout(function() {\n    doc._getLatestTimeout = null;\n    // Send another fetch at the end of the final timeout interval if we were\n    // debounced to make sure we didn't miss anything\n    if (debounced) {\n      doc.connection.sendFetch(doc, doc.version);\n    }\n  }, 5000);\n  return;\n};\n\n// Called whenever (you guessed it!) the connection state changes. This will\n// happen when we get disconnected & reconnect.\nDoc.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend) {\n    this.flush();\n  } else {\n    this.subscribed = false;\n    this._clearAction();\n  }\n};\n\nDoc.prototype._clearAction = function() {\n  this.action = null;\n  this.flush();\n  this._emitNothingPending();\n};\n\n// Send the next pending op to the server, if we can.\n//\n// Only one operation can be in-flight at a time. If an operation is already on\n// its way, or we're not currently connected, this method does nothing.\nDoc.prototype.flush = function() {\n  // Ignore if we can't send or we are already sending an op\n  if (!this.connection.canSend || this.inflightData) return;\n\n  // Pump and dump any no-ops from the front of the pending op list.\n  var opData;\n  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {\n    var callbacks = opData.callbacks;\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](opData.error);\n    }\n    this.pendingData.shift();\n  }\n\n  // Send first pending op unless paused\n  if (!this.paused && this.pendingData.length) {\n    this._sendOpData();\n    return;\n  }\n\n  // Ignore if an action is already in process\n  if (this.action) return;\n  // Once all ops are sent, perform subscriptions and fetches\n  var version = (this.state === 'ready') ? this.version : null;\n\n  if (this.subscribed && !this.wantSubscribe) {\n    this.action = 'unsubscribe';\n    this.connection.sendUnsubscribe(this);\n\n  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {\n    this.action = 'fetch';\n    this.connection.sendFetch(this, version);\n\n  } else if (!this.subscribed && this.wantSubscribe) {\n    this.action = 'subscribe';\n    this.connection.sendSubscribe(this, version);\n  }\n};\n\n\n// ****** Subscribing, unsubscribing and fetching\n\n// Value is true, false or 'fetch'.\nDoc.prototype._setWantSubscribe = function(value, callback, err) {\n  if (this.subscribed === this.wantSubscribe &&\n      (this.subscribed === value || value === 'fetch' && this.subscribed)) {\n    if (callback) callback(err);\n    return;\n  }\n\n  // If we want to subscribe, don't weaken it to a fetch.\n  if (value !== 'fetch' || this.wantSubscribe !== true) {\n    this.wantSubscribe = value;\n  }\n\n  if (callback) this._subscribeCallbacks.push(callback);\n  this.flush();\n};\n\n// Open the document. There is no callback and no error handling if you're\n// already connected.\n//\n// Only call this once per document.\nDoc.prototype.subscribe = function(callback) {\n  this._setWantSubscribe(true, callback);\n};\n\n// Unsubscribe. The data will stay around in local memory, but we'll stop\n// receiving updates.\nDoc.prototype.unsubscribe = function(callback) {\n  this._setWantSubscribe(false, callback);\n};\n\n// Call to request fresh data from the server.\nDoc.prototype.fetch = function(callback) {\n  this._setWantSubscribe('fetch', callback);\n};\n\n// Called when our subscribe, fetch or unsubscribe messages are acknowledged.\nDoc.prototype._finishSub = function(err) {\n  if (!this._subscribeCallbacks.length) return;\n  for (var i = 0; i < this._subscribeCallbacks.length; i++) {\n    this._subscribeCallbacks[i](err);\n  }\n  this._subscribeCallbacks.length = 0;\n};\n\n\n// Operations\n\n\n// ************ Dealing with operations.\n\n// Helper function to set opData to contain a no-op.\nvar setNoOp = function(opData) {\n  delete opData.op;\n  delete opData.create;\n  delete opData.del;\n};\n\nvar isNoOp = function(opData) {\n  return !opData.op && !opData.create && !opData.del;\n}\n\n// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.\nvar tryCompose = function(type, data1, data2) {\n  if (data1.create && data2.del) {\n    setNoOp(data1);\n  } else if (data1.create && data2.op) {\n    // Compose the data into the create data.\n    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;\n    data1.create.data = type.apply(data, data2.op);\n  } else if (isNoOp(data1)) {\n    data1.create = data2.create;\n    data1.del = data2.del;\n    data1.op = data2.op;\n  } else if (data1.op && data2.op && type.compose) {\n    data1.op = type.compose(data1.op, data2.op);\n  } else {\n    return false;\n  }\n  return true;\n};\n\n// Transform server op data by a client op, and vice versa. Ops are edited in place.\nvar xf = function(client, server) {\n  // In this case, we're in for some fun. There are some local operations\n  // which are totally invalid - either the client continued editing a\n  // document that someone else deleted or a document was created both on the\n  // client and on the server. In either case, the local document is way\n  // invalid and the client's ops are useless.\n  //\n  // The client becomes a no-op, and we keep the server op entirely.\n  if (server.create || server.del) return setNoOp(client);\n  if (client.create) throw new Error('Invalid state. This is a bug. ' + this.collection + ' ' + this.name);\n\n  // The client has deleted the document while the server edited it. Kill the\n  // server's op.\n  if (client.del) return setNoOp(server);\n\n  // We only get here if either the server or client ops are no-op. Carry on,\n  // nothing to see here.\n  if (!server.op || !client.op) return;\n\n  // They both edited the document. This is the normal case for this function -\n  // as in, most of the time we'll end up down here.\n  //\n  // You should be wondering why I'm using client.type instead of this.type.\n  // The reason is, if we get ops at an old version of the document, this.type\n  // might be undefined or a totally different type. By pinning the type to the\n  // op data, we make sure the right type has its transform function called.\n  if (client.type.transformX) {\n    var result = client.type.transformX(client.op, server.op);\n    client.op = result[0];\n    server.op = result[1];\n  } else {\n    var _c = client.type.transform(client.op, server.op, 'left');\n    var _s = client.type.transform(server.op, client.op, 'right');\n    client.op = _c; server.op = _s;\n  }\n};\n\n/**\n * Applies the operation to the snapshot\n *\n * If the operation is create or delete it emits `create` or `del`.  Then the\n * operation is applied to the snapshot and `op` and `after op` are emitted.  If\n * the type supports incremental updates and `this.incremental` is true we fire\n * `op` after every small operation.\n *\n * This is the only function to fire the above mentioned events.\n *\n * @private\n */\nDoc.prototype._otApply = function(opData, context) {\n  this.locked = true;\n\n  if (opData.create) {\n    // If the type is currently set, it means we tried creating the document\n    // and someone else won. client create x server create = server create.\n    var create = opData.create;\n    this._setType(create.type);\n    this.snapshot = this.type.create(create.data);\n\n    // This is a bit heavyweight, but I want the created event to fire outside of the lock.\n    this.once('unlock', function() {\n      this.emit('create', context);\n    });\n  } else if (opData.del) {\n    // The type should always exist in this case. del x _ = del\n    var oldSnapshot = this.snapshot;\n    this._setType(null);\n    this.once('unlock', function() {\n      this.emit('del', context, oldSnapshot);\n    });\n  } else if (opData.op) {\n    if (!this.type) throw new Error('Document does not exist. ' + this.collection + ' ' + this.name);\n\n    var type = this.type;\n\n    var op = opData.op;\n\n    // The context needs to be told we're about to edit, just in case it needs\n    // to store any extra data. (text-tp2 has this constraint.)\n    for (var i = 0; i < this.editingContexts.length; i++) {\n      var c = this.editingContexts[i];\n      if (c != context && c._beforeOp) c._beforeOp(opData.op);\n    }\n\n    this.emit('before op', op, context);\n\n    // This exists so clients can pull any necessary data out of the snapshot\n    // before it gets changed.  Previously we kept the old snapshot object and\n    // passed it to the op event handler. However, apply no longer guarantees\n    // the old object is still valid.\n    //\n    // Because this could be totally unnecessary work, its behind a flag. set\n    // doc.incremental to enable.\n    if (this.incremental && type.incrementalApply) {\n      var _this = this;\n      type.incrementalApply(this.snapshot, op, function(o, snapshot) {\n        _this.snapshot = snapshot;\n        _this.emit('op', o, context);\n      });\n    } else {\n      // This is the most common case, simply applying the operation to the local snapshot.\n      this.snapshot = type.apply(this.snapshot, op);\n      this.emit('op', op, context);\n    }\n  }\n  // Its possible for none of the above cases to match, in which case the op is\n  // a no-op. This will happen when a document has been deleted locally and\n  // remote ops edit the document.\n\n\n  this.locked = false;\n  this.emit('unlock');\n\n  if (opData.op) {\n    var contexts = this.editingContexts;\n    // Notify all the contexts about the op (well, all the contexts except\n    // the one which initiated the submit in the first place).\n    // NOTE Handle this with events?\n    for (var i = 0; i < contexts.length; i++) {\n      var c = contexts[i];\n      if (c != context && c._onOp) c._onOp(opData.op);\n    }\n    for (var i = 0; i < contexts.length; i++) {\n      if (contexts[i].shouldBeRemoved) contexts.splice(i--, 1);\n    }\n\n    return this.emit('after op', opData.op, context);\n  }\n};\n\n\n\n// ***** Sending operations\n\nDoc.prototype.retry = function() {\n  if (!this.inflightData) return;\n  var threshold = 5000 * Math.pow(2, this.inflightData.retries);\n  if (this.inflightData.sentAt < Date.now() - threshold) {\n    this.connection.emit('retry', this);\n    this._sendOpData();\n  }\n};\n\n// Actually send op data to the server.\nDoc.prototype._sendOpData = function() {\n  // Wait until we have a src id from the server\n  var src = this.connection.id;\n  if (!src) return;\n\n  // When there is no inflightData, send the first item in pendingData. If\n  // there is inflightData, try sending it again\n  if (!this.inflightData) {\n    // Send first pending op\n    this.inflightData = this.pendingData.shift();\n  }\n  var data = this.inflightData;\n  if (!data) {\n    throw new Error('no data to send on call to _sendOpData');\n  }\n\n  // Track data for retrying ops\n  data.sentAt = Date.now();\n  data.retries = (data.retries == null) ? 0 : data.retries + 1;\n\n  // The src + seq number is a unique ID representing this operation. This tuple\n  // is used on the server to detect when ops have been sent multiple times and\n  // on the client to match acknowledgement of an op back to the inflightData.\n  // Note that the src could be different from this.connection.id after a\n  // reconnect, since an op may still be pending after the reconnection and\n  // this.connection.id will change. In case an op is sent multiple times, we\n  // also need to be careful not to override the original seq value.\n  if (data.seq == null) data.seq = this.connection.seq++;\n\n  this.connection.sendOp(this, data);\n\n  // src isn't needed on the first try, since the server session will have the\n  // same id, but it must be set on the inflightData in case it is sent again\n  // after a reconnect and the connection's id has changed by then\n  if (data.src == null) data.src = src;\n};\n\n\n// Queues the operation for submission to the server and applies it locally.\n//\n// Internal method called to do the actual work for submitOp(), create() and del().\n// @private\n//\n// @param opData\n// @param [opData.op]\n// @param [opData.del]\n// @param [opData.create]\n// @param [context] the editing context\n// @param [callback] called when operation is submitted\nDoc.prototype._submitOpData = function(opData, context, callback) {\n  if (typeof context === 'function') {\n    callback = context;\n    context = true; // The default context is true.\n  }\n  if (context == null) context = true;\n\n  if (this.locked) {\n    var err = \"Cannot call submitOp from inside an 'op' event handler. \" + this.collection + ' ' + this.name;\n    if (callback) return callback(err);\n    throw new Error(err);\n  }\n\n  // The opData contains either op, create, delete, or none of the above (a no-op).\n  if (opData.op) {\n    if (!this.type) {\n      var err = 'Document has not been created';\n      if (callback) return callback(err);\n      throw new Error(err);\n    }\n    // Try to normalize the op. This removes trailing skip:0's and things like that.\n    if (this.type.normalize) opData.op = this.type.normalize(opData.op);\n  }\n\n  if (!this.state) {\n    this.state = 'floating';\n  }\n\n  opData.type = this.type;\n  opData.callbacks = [];\n\n  // If the type supports composes, try to compose the operation onto the end\n  // of the last pending operation.\n  var operation;\n  var previous = this.pendingData[this.pendingData.length - 1];\n\n  if (previous && tryCompose(this.type, previous, opData)) {\n    operation = previous;\n  } else {\n    operation = opData;\n    this.pendingData.push(opData);\n  }\n  if (callback) operation.callbacks.push(callback);\n\n  this._otApply(opData, context);\n\n  // The call to flush is in a timeout so if submitOp() is called multiple\n  // times in a closure all the ops are combined before being sent to the\n  // server. It doesn't matter if flush is called a bunch of times.\n  var _this = this;\n  setTimeout((function() { _this.flush(); }), 0);\n};\n\n\n// *** Client OT entrypoints.\n\n// Submit an operation to the document.\n//\n// @param operation handled by the OT type\n// @param [context] editing context\n// @param [callback] called after operation submitted\n//\n// @fires before op, op, after op\nDoc.prototype.submitOp = function(op, context, callback) {\n  this._submitOpData({op: op}, context, callback);\n};\n\n// Create the document, which in ShareJS semantics means to set its type. Every\n// object implicitly exists in the database but has no data and no type. Create\n// sets the type of the object and can optionally set some initial data on the\n// object, depending on the type.\n//\n// @param type  OT type\n// @param data  initial\n// @param context  editing context\n// @param callback  called when operation submitted\nDoc.prototype.create = function(type, data, context, callback) {\n  if (typeof data === 'function') {\n    // Setting the context to be the callback function in this case so _submitOpData\n    // can handle the default value thing.\n    context = data;\n    data = undefined;\n  }\n\n  if (this.type) {\n    var err = 'Document already exists';\n    if (callback) return callback(err);\n    throw new Error(err);\n  }\n\n  var op = {create: {type:type, data:data}};\n  this._submitOpData(op, context, callback);\n};\n\n// Delete the document. This creates and submits a delete operation to the\n// server. Deleting resets the object's type to null and deletes its data. The\n// document still exists, and still has the version it used to have before you\n// deleted it (well, old version +1).\n//\n// @param context   editing context\n// @param callback  called when operation submitted\nDoc.prototype.del = function(context, callback) {\n  if (!this.type) {\n    var err = 'Document does not exist';\n    if (callback) return callback(err);\n    throw new Error(err);\n  }\n\n  this._submitOpData({del: true}, context, callback);\n};\n\n\n// Stops the document from sending any operations to the server.\nDoc.prototype.pause = function() {\n  this.paused = true;\n};\n\n// Continue sending operations to the server\nDoc.prototype.resume = function() {\n  this.paused = false;\n  this.flush();\n};\n\n\n// *** Receiving operations\n\n\n// This will be called when the server rejects our operations for some reason.\n// There's not much we can do here if the OT type is noninvertable, but that\n// shouldn't happen too much in real life because readonly documents should be\n// flagged as such. (I should probably figure out a flag for that).\n//\n// This does NOT get called if our op fails to reach the server for some reason\n// - we optimistically assume it'll make it there eventually.\nDoc.prototype._tryRollback = function(opData) {\n  // This is probably horribly broken.\n  if (opData.create) {\n    this._setType(null);\n\n    // I don't think its possible to get here if we aren't in a floating state.\n    if (this.state === 'floating')\n      this.state = null;\n    else\n      console.warn('Rollback a create from state ' + this.state);\n\n  } else if (opData.op && opData.type.invert) {\n    opData.op = opData.type.invert(opData.op);\n\n    // Transform the undo operation by any pending ops.\n    for (var i = 0; i < this.pendingData.length; i++) {\n      xf(this.pendingData[i], opData);\n    }\n\n    // ... and apply it locally, reverting the changes.\n    //\n    // This operation is applied to look like it comes from a remote context.\n    // I'm still not 100% sure about this functionality, because its really a\n    // local op. Basically, the problem is that if the client's op is rejected\n    // by the server, the editor window should update to reflect the undo.\n    this._otApply(opData, false);\n  } else if (opData.op || opData.del) {\n    // This is where an undo stack would come in handy.\n    this._setType(null);\n    this.version = null;\n    this.state = null;\n    this.subscribed = false;\n    this.emit('error', \"Op apply failed and the operation could not be reverted\");\n\n    // Trigger a fetch. In our invalid state, we can't really do anything.\n    this.fetch();\n    this.flush();\n  }\n};\n\nDoc.prototype._clearInflightOp = function(error) {\n  var callbacks = this.inflightData.callbacks;\n  for (var i = 0; i < callbacks.length; i++) {\n    callbacks[i](error || this.inflightData.error);\n  }\n\n  this.inflightData = null;\n  this.flush();\n  this._emitNothingPending();\n};\n\n// This is called when the server acknowledges an operation from the client.\nDoc.prototype._opAcknowledged = function(msg) {\n  // Our inflight op has been acknowledged, so we can throw away the inflight data.\n  // (We were only holding on to it incase we needed to resend the op.)\n  if (!this.state) {\n    throw new Error('opAcknowledged called from a null state. This should never happen. ' + this.collection + ' ' + this.name);\n  } else if (this.state === 'floating') {\n    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op. ' + this.collection + ' ' + this.name);\n\n    // Our create has been acknowledged. This is the same as ingesting some data.\n    this.version = msg.v;\n    this.state = 'ready';\n    var _this = this;\n    setTimeout(function() { _this.emit('ready'); }, 0);\n  } else {\n    // We already have a snapshot. The snapshot should be at the acknowledged\n    // version, because the server has sent us all the ops that have happened\n    // before acknowledging our op.\n\n    // This should never happen - something is out of order.\n    if (msg.v !== this.version) {\n      throw new Error('Invalid version from server. This can happen when you submit ops in a submitOp callback. Expected: ' + this.version + ' Message version: ' + msg.v + ' ' + this.collection + ' ' + this.name);\n    }\n  }\n\n  // The op was committed successfully. Increment the version number\n  this.version++;\n\n  this._clearInflightOp();\n};\n\n\n// Creates an editing context\n//\n// The context is an object responding to getSnapshot(), submitOp() and\n// destroy(). It also has all the methods from the OT type mixed in.\n// If the document is destroyed, the detach() method is called on the context.\nDoc.prototype.createContext = function() {\n  var type = this.type;\n  if (!type) throw new Error('Missing type ' + this.collection + ' ' + this.name);\n\n  // I could use the prototype chain to do this instead, but Object.create\n  // isn't defined on old browsers. This will be fine.\n  var doc = this;\n  var context = {\n    getSnapshot: function() {\n      return doc.snapshot;\n    },\n    submitOp: function(op, callback) {\n      doc.submitOp(op, context, callback);\n    },\n    destroy: function() {\n      if (this.detach) {\n        this.detach();\n        // Don't double-detach.\n        delete this.detach;\n      }\n      // It will be removed from the actual editingContexts list next time\n      // we receive an op on the document (and the list is iterated through).\n      //\n      // This is potentially dodgy, allowing a memory leak if you create &\n      // destroy a whole bunch of contexts without receiving or sending any ops\n      // to the document.\n      //\n      // NOTE Why can't we destroy contexts immediately?\n      delete this._onOp;\n      this.shouldBeRemoved = true;\n    },\n\n    // This is dangerous, but really really useful for debugging. I hope people\n    // don't depend on it.\n    _doc: this,\n  };\n\n  if (type.api) {\n    // Copy everything else from the type's API into the editing context.\n    for (var k in type.api) {\n      context[k] = type.api[k];\n    }\n  } else {\n    context.provides = {};\n  }\n\n  this.editingContexts.push(context);\n\n  return context;\n};\n\n\n/**\n * Destroy all editing contexts\n */\nDoc.prototype.removeContexts = function() {\n  for (var i = 0; i < this.editingContexts.length; i++) {\n    this.editingContexts[i].destroy();\n  }\n  this.editingContexts.length = 0;\n};\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/types/index.js":"\nexports.ottypes = {};\nexports.registerType = function(type) {\n  if (type.name) exports.ottypes[type.name] = type;\n  if (type.uri) exports.ottypes[type.uri] = type;\n};\n\nexports.registerType(require('ot-json0').type);\nexports.registerType(require('ot-text').type);\nexports.registerType(require('ot-text-tp2').type);\n\n// The types register themselves on their respective types.\nrequire('./text-api');\nrequire('./text-tp2-api');\n\n// The JSON API is buggy!! Please submit a pull request fixing it if you want to use it.\n//require('./json-api');\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/types/text-api.js":"// Text document API for the 'text' type.\n\n// The API implements the standard text API methods. In particular:\n//\n// - getLength() returns the length of the document in characters\n// - getText() returns a string of the document\n// - insert(pos, text, [callback]) inserts text at position pos in the document\n// - remove(pos, length, [callback]) removes length characters at position pos\n//\n// Events are implemented by just adding the appropriate methods to your\n// context object.\n// onInsert(pos, text): Called when text is inserted.\n// onRemove(pos, length): Called when text is removed.\n\nvar type = require('ot-text').type;\n\ntype.api = {\n  provides: {text: true},\n\n  // Returns the number of characters in the string\n  getLength: function() { return this.getSnapshot().length; },\n\n\n  // Returns the text content of the document\n  get: function() { return this.getSnapshot(); },\n\n  getText: function() {\n    console.warn(\"`getText()` is deprecated; use `get()` instead.\");\n    return this.get();\n  },\n\n  // Insert the specified text at the given position in the document\n  insert: function(pos, text, callback) {\n    return this.submitOp([pos, text], callback);\n  },\n\n  remove: function(pos, length, callback) {\n    return this.submitOp([pos, {d:length}], callback);\n  },\n\n  // When you use this API, you should implement these two methods\n  // in your editing context.\n  //onInsert: function(pos, text) {},\n  //onRemove: function(pos, removedLength) {},\n\n  _onOp: function(op) {\n    var pos = 0;\n    var spos = 0;\n    for (var i = 0; i < op.length; i++) {\n      var component = op[i];\n      switch (typeof component) {\n        case 'number':\n          pos += component;\n          spos += component;\n          break;\n        case 'string':\n          if (this.onInsert) this.onInsert(pos, component);\n          pos += component.length;\n          break;\n        case 'object':\n          if (this.onRemove) this.onRemove(pos, component.d);\n          spos += component.d;\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/types/text-tp2-api.js":"// Text document API for text-tp2\n\nvar type = require('ot-text-tp2').type;\nvar takeDoc = type._takeDoc;\nvar append = type._append;\n\nvar appendSkipChars = function(op, doc, pos, maxlength) {\n  while ((maxlength == null || maxlength > 0) && pos.index < doc.data.length) {\n    var part = takeDoc(doc, pos, maxlength, true);\n    if (maxlength != null && typeof part === 'string') {\n      maxlength -= part.length;\n    }\n    append(op, part.length || part);\n  }\n};\n\ntype.api = {\n  provides: {text: true},\n\n  // Number of characters in the string\n  getLength: function() { return this.getSnapshot().charLength; },\n\n  // Flatten the document into a string\n  get: function() {\n    var snapshot = this.getSnapshot();\n    var strings = [];\n\n    for (var i = 0; i < snapshot.data.length; i++) {\n      var elem = snapshot.data[i];\n      if (typeof elem == 'string') {\n        strings.push(elem);\n      }\n    }\n\n    return strings.join('');\n  },\n\n  getText: function() {\n    console.warn(\"`getText()` is deprecated; use `get()` instead.\");\n    return this.get();\n  },\n\n  // Insert text at pos\n  insert: function(pos, text, callback) {\n    if (pos == null) pos = 0;\n\n    var op = [];\n    var docPos = {index: 0, offset: 0};\n    var snapshot = this.getSnapshot();\n\n    // Skip to the specified position\n    appendSkipChars(op, snapshot, docPos, pos);\n\n    // Append the text\n    append(op, {i: text});\n    appendSkipChars(op, snapshot, docPos);\n    this.submitOp(op, callback);\n    return op;\n  },\n\n  // Remove length of text at pos\n  remove: function(pos, len, callback) {\n    var op = [];\n    var docPos = {index: 0, offset: 0};\n    var snapshot = this.getSnapshot();\n\n    // Skip to the position\n    appendSkipChars(op, snapshot, docPos, pos);\n\n    while (len > 0) {\n      var part = takeDoc(snapshot, docPos, len, true);\n\n      // We only need to delete actual characters. This should also be valid if\n      // we deleted all the tombstones in the document here.\n      if (typeof part === 'string') {\n        append(op, {d: part.length});\n        len -= part.length;\n      } else {\n        append(op, part);\n      }\n    }\n\n    appendSkipChars(op, snapshot, docPos);\n    this.submitOp(op, callback);\n    return op;\n  },\n\n  _beforeOp: function() {\n    // Its a shame we need this. This also currently relies on snapshots being\n    // cloned during apply(). This is used in _onOp below to figure out what\n    // text was _actually_ inserted and removed.\n    //\n    // Maybe instead we should do all the _onOp logic here and store the result\n    // then play the events when _onOp is actually called or something.\n    this.__prevSnapshot = this.getSnapshot();\n  },\n\n  _onOp: function(op) {\n    var textPos = 0;\n    var docPos = {index:0, offset:0};\n    // The snapshot we get here is the document state _AFTER_ the specified op\n    // has been applied. That means any deleted characters are now tombstones.\n    var prevSnapshot = this.__prevSnapshot;\n\n    for (var i = 0; i < op.length; i++) {\n      var component = op[i];\n      var part, remainder;\n\n      if (typeof component == 'number') {\n        // Skip\n        for (remainder = component;\n            remainder > 0;\n            remainder -= part.length || part) {\n\n          part = takeDoc(prevSnapshot, docPos, remainder);\n          if (typeof part === 'string')\n            textPos += part.length;\n        }\n      } else if (component.i != null) {\n        // Insert\n        if (typeof component.i == 'string') {\n          // ... and its an insert of text, not insert of tombstones\n          if (this.onInsert) this.onInsert(textPos, component.i);\n          textPos += component.i.length;\n        }\n      } else {\n        // Delete\n        for (remainder = component.d;\n            remainder > 0;\n            remainder -= part.length || part) {\n\n          part = takeDoc(prevSnapshot, docPos, remainder);\n          if (typeof part == 'string' && this.onRemove)\n            this.onRemove(textPos, part.length);\n        }\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/client/emitter.js":"var EventEmitter = require('events').EventEmitter;\n\nexports.EventEmitter = EventEmitter;\nexports.mixin = mixin;\n\nfunction mixin(Constructor) {\n  for (var key in EventEmitter.prototype) {\n    Constructor.prototype[key] = EventEmitter.prototype[key];\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/client/query.js":"var emitter = require('./emitter');\n\n// Queries are live requests to the database for particular sets of fields.\n//\n// The server actively tells the client when there's new data that matches\n// a set of conditions.\nvar Query = exports.Query = function(type, connection, id, collection, query, options, callback) {\n  emitter.EventEmitter.call(this);\n\n  // 'fetch' or 'sub'\n  this.type = type;\n\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n\n  // The query itself. For mongo, this should look something like {\"data.x\":5}\n  this.query = query;\n\n  // Resultant document action for the server. Fetch mode will automatically\n  // fetch all results. Subscribe mode will automatically subscribe all\n  // results. Results are never unsubscribed.\n  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.\n  if (this.docMode === 'subscribe') this.docMode = 'sub';\n\n  // Do we repoll the entire query whenever anything changes? (As opposed to\n  // just polling the changed item). This needs to be enabled to be able to use\n  // ordered queries (sortby:) and paginated queries. Set to undefined, it will\n  // be enabled / disabled automatically based on the query's properties.\n  this.poll = options.poll;\n\n  // The backend we actually hit. If this isn't defined, it hits the snapshot\n  // database. Otherwise this can be used to hit another configured query\n  // index.\n  this.backend = options.backend || options.source;\n\n  // A list of resulting documents. These are actual documents, complete with\n  // data and all the rest. If fetch is false, these documents will not\n  // have any data. You should manually call fetch() or subscribe() on them.\n  //\n  // Calling subscribe() might be a good idea anyway, as you won't be\n  // subscribed to the documents by default.\n  this.knownDocs = options.knownDocs || [];\n  this.results = [];\n\n  // Do we have some initial data?\n  this.ready = false;\n\n  this.callback = callback;\n};\nemitter.mixin(Query);\n\nQuery.prototype.action = 'qsub';\n\n// Helper for subscribe & fetch, since they share the same message format.\n//\n// This function actually issues the query.\nQuery.prototype._execute = function() {\n  if (!this.connection.canSend) return;\n\n  if (this.docMode) {\n    var collectionVersions = {};\n    // Collect the version of all the documents in the current result set so we\n    // don't need to be sent their snapshots again.\n    for (var i = 0; i < this.knownDocs.length; i++) {\n      var doc = this.knownDocs[i];\n      if (doc.version == null) continue;\n      var c = collectionVersions[doc.collection] =\n        (collectionVersions[doc.collection] || {});\n      c[doc.name] = doc.version;\n    }\n  }\n\n  var msg = {\n    a: 'q' + this.type,\n    id: this.id,\n    c: this.collection,\n    o: {},\n    q: this.query,\n  };\n\n  if (this.docMode) {\n    msg.o.m = this.docMode;\n    // This should be omitted if empty, but whatever.\n    msg.o.vs = collectionVersions;\n  }\n  if (this.backend != null) msg.o.b = this.backend;\n  if (this.poll !== undefined) msg.o.p = this.poll;\n\n  this.connection.send(msg);\n};\n\n// Make a list of documents from the list of server-returned data objects\nQuery.prototype._dataToDocs = function(data) {\n  var results = [];\n  var lastType;\n  for (var i = 0; i < data.length; i++) {\n    var docData = data[i];\n\n    // Types are only put in for the first result in the set and every time the type changes in the list.\n    if (docData.type) {\n      lastType = docData.type;\n    } else {\n      docData.type = lastType;\n    }\n\n    // This will ultimately call doc.ingestData(), which is what populates\n    // the doc snapshot and version with the data returned by the query\n    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);\n    results.push(doc);\n  }\n  return results;\n};\n\n// Destroy the query object. Any subsequent messages for the query will be\n// ignored by the connection. You should unsubscribe from the query before\n// destroying it.\nQuery.prototype.destroy = function() {\n  if (this.connection.canSend && this.type === 'sub') {\n    this.connection.send({a:'qunsub', id:this.id});\n  }\n\n  this.connection._destroyQuery(this);\n};\n\nQuery.prototype._onConnectionStateChanged = function(state, reason) {\n  if (this.connection.state === 'connecting') {\n    this._execute();\n  }\n};\n\n// Internal method called from connection to pass server messages to the query.\nQuery.prototype._onMessage = function(msg) {\n  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {\n    console.warn('Invalid message sent to query', msg, this);\n    return;\n  }\n\n  if (msg.error) this.emit('error', msg.error);\n\n  switch (msg.a) {\n    case 'qfetch':\n      var results = msg.data ? this._dataToDocs(msg.data) : undefined;\n      if (this.callback) this.callback(msg.error, results, msg.extra);\n      // Once a fetch query gets its data, it is destroyed.\n      this.connection._destroyQuery(this);\n      break;\n\n    case 'q':\n      // Query diff data (inserts and removes)\n      if (msg.diff) {\n        // We need to go through the list twice. First, we'll ingest all the\n        // new documents and set them as subscribed.  After that we'll emit\n        // events and actually update our list. This avoids race conditions\n        // around setting documents to be subscribed & unsubscribing documents\n        // in event callbacks.\n        for (var i = 0; i < msg.diff.length; i++) {\n          var d = msg.diff[i];\n          if (d.type === 'insert') d.values = this._dataToDocs(d.values);\n        }\n\n        for (var i = 0; i < msg.diff.length; i++) {\n          var d = msg.diff[i];\n          switch (d.type) {\n            case 'insert':\n              var newDocs = d.values;\n              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));\n              this.emit('insert', newDocs, d.index);\n              break;\n            case 'remove':\n              var howMany = d.howMany || 1;\n              var removed = this.results.splice(d.index, howMany);\n              this.emit('remove', removed, d.index);\n              break;\n            case 'move':\n              var howMany = d.howMany || 1;\n              var docs = this.results.splice(d.from, howMany);\n              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));\n              this.emit('move', docs, d.from, d.to);\n              break;\n          }\n        }\n      }\n\n      if (msg.extra !== void 0) {\n        this.emit('extra', msg.extra);\n      }\n      break;\n    case 'qsub':\n      // This message replaces the entire result set with the set passed.\n      if (!msg.error) {\n        var previous = this.results;\n\n        // Then add everything in the new result set.\n        this.results = this.knownDocs = this._dataToDocs(msg.data);\n        this.extra = msg.extra;\n\n        this.ready = true;\n        this.emit('change', this.results, previous);\n      }\n      if (this.callback) {\n        this.callback(msg.error, this.results, this.extra);\n        delete this.callback;\n      }\n      break;\n  }\n};\n\n// Change the thing we're searching for. This isn't fully supported on the\n// backend (it destroys the old query and makes a new one) - but its\n// programatically useful and I might add backend support at some point.\nQuery.prototype.setQuery = function(q) {\n  if (this.type !== 'sub') throw new Error('cannot change a fetch query');\n\n  this.query = q;\n  if (this.connection.canSend) {\n    // There's no 'change' message to send to the server. Just resubscribe.\n    this.connection.send({a:'qunsub', id:this.id});\n    this._execute();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/client/textarea.js":"/* This contains the textarea binding for ShareJS. This binding is really\n * simple, and a bit slow on big documents (Its O(N). However, it requires no\n * changes to the DOM and no heavy libraries like ace. It works for any kind of\n * text input field.\n *\n * You probably want to use this binding for small fields on forms and such.\n * For code editors or rich text editors or whatever, I recommend something\n * heavier.\n */\n\n var Doc = require('./doc').Doc;\n\n/* applyChange creates the edits to convert oldval -> newval.\n *\n * This function should be called every time the text element is changed.\n * Because changes are always localised, the diffing is quite easy. We simply\n * scan in from the start and scan in from the end to isolate the edited range,\n * then delete everything that was removed & add everything that was added.\n * This wouldn't work for complex changes, but this function should be called\n * on keystroke - so the edits will mostly just be single character changes.\n * Sometimes they'll paste text over other text, but even then the diff\n * generated by this algorithm is correct.\n *\n * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.\n */\nvar applyChange = function(ctx, oldval, newval) {\n  // Strings are immutable and have reference equality. I think this test is O(1), so its worth doing.\n  if (oldval === newval) return;\n\n  var commonStart = 0;\n  while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {\n    commonStart++;\n  }\n\n  var commonEnd = 0;\n  while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) &&\n      commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {\n    commonEnd++;\n  }\n\n  if (oldval.length !== commonStart + commonEnd) {\n    ctx.remove(commonStart, oldval.length - commonStart - commonEnd);\n  }\n  if (newval.length !== commonStart + commonEnd) {\n    ctx.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));\n  }\n};\n\n// Attach a textarea to a document's editing context.\n//\n// The context is optional, and will be created from the document if its not\n// specified.\nDoc.prototype.attachTextarea = function(elem, ctx) {\n  if (!ctx) ctx = this.createContext();\n\n  if (!ctx.provides.text) throw new Error('Cannot attach to non-text document');\n\n  elem.value = ctx.get();\n\n  // The current value of the element's text is stored so we can quickly check\n  // if its been changed in the event handlers. This is mostly for browsers on\n  // windows, where the content contains \\r\\n newlines. applyChange() is only\n  // called after the \\r\\n newlines are converted, and that check is quite\n  // slow. So we also cache the string before conversion so we can do a quick\n  // check incase the conversion isn't needed.\n  var prevvalue;\n\n  // Replace the content of the text area with newText, and transform the\n  // current cursor by the specified function.\n  var replaceText = function(newText, transformCursor) {\n    if (transformCursor) {\n      var newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];\n    }\n\n    // Fixate the window's scroll while we set the element's value. Otherwise\n    // the browser scrolls to the element.\n    var scrollTop = elem.scrollTop;\n    elem.value = newText;\n    prevvalue = elem.value; // Not done on one line so the browser can do newline conversion.\n    if (elem.scrollTop !== scrollTop) elem.scrollTop = scrollTop;\n\n    // Setting the selection moves the cursor. We'll just have to let your\n    // cursor drift if the element isn't active, though usually users don't\n    // care.\n    if (newSelection && window.document.activeElement === elem) {\n      elem.selectionStart = newSelection[0];\n      elem.selectionEnd = newSelection[1];\n    }\n  };\n\n  replaceText(ctx.get());\n\n\n  // *** remote -> local changes\n\n  ctx.onInsert = function(pos, text) {\n    var transformCursor = function(cursor) {\n      return pos < cursor ? cursor + text.length : cursor;\n    };\n\n    // Remove any window-style newline characters. Windows inserts these, and\n    // they mess up the generated diff.\n    var prev = elem.value.replace(/\\r\\n/g, '\\n');\n    replaceText(prev.slice(0, pos) + text + prev.slice(pos), transformCursor);\n  };\n\n  ctx.onRemove = function(pos, length) {\n    var transformCursor = function(cursor) {\n      // If the cursor is inside the deleted region, we only want to move back to the start\n      // of the region. Hence the Math.min.\n      return pos < cursor ? cursor - Math.min(length, cursor - pos) : cursor;\n    };\n\n    var prev = elem.value.replace(/\\r\\n/g, '\\n');\n    replaceText(prev.slice(0, pos) + prev.slice(pos + length), transformCursor);\n  };\n\n\n  // *** local -> remote changes\n\n  // This function generates operations from the changed content in the textarea.\n  var genOp = function(event) {\n    // In a timeout so the browser has time to propogate the event's changes to the DOM.\n    setTimeout(function() {\n      if (elem.value !== prevvalue) {\n        prevvalue = elem.value;\n        applyChange(ctx, ctx.get(), elem.value.replace(/\\r\\n/g, '\\n'));\n      }\n    }, 0);\n  };\n\n  var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];\n  for (var i = 0; i < eventNames.length; i++) {\n    var e = eventNames[i];\n    if (elem.addEventListener) {\n      elem.addEventListener(e, genOp, false);\n    } else {\n      elem.attachEvent('on' + e, genOp);\n    }\n  }\n\n  ctx.detach = function() {\n    for (var i = 0; i < eventNames.length; i++) {\n      var e = eventNames[i];\n      if (elem.removeEventListener) {\n        elem.removeEventListener(e, genOp, false);\n      } else {\n        elem.detachEvent('on' + e, genOp);\n      }\n    }\n  };\n\n  return ctx;\n};\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/server/rest.js":"// This implements ShareJS's REST API.\n\nvar Router = require('express').Router;\nvar url = require('url');\n\n\n// ****  Utility functions\n\n\nvar send403 = function(res, message) {\n  if (message == null) message = 'Forbidden\\n';\n\n  res.writeHead(403, {'Content-Type': 'text/plain'});\n  res.end(message);\n};\n\nvar send404 = function(res, message) {\n  if (message == null) message = '404: Your document could not be found.\\n';\n\n  res.writeHead(404, {'Content-Type': 'text/plain'});\n  res.end(message);\n};\n\nvar send409 = function(res, message) {\n  if (message == null) message = '409: Your operation could not be applied.\\n';\n\n  res.writeHead(409, {'Content-Type': 'text/plain'});\n  res.end(message);\n};\n\nvar sendError = function(res, message, head) {\n  if (message === 'forbidden') {\n    if (head) {\n      send403(res, \"\");\n    } else {\n      send403(res);\n    }\n  } else if (message === 'Document created remotely') {\n    if (head) {\n      send409(res, \"\");\n    } else {\n      send409(res, message + '\\n');\n    }\n  } else {\n    //console.warn(\"REST server does not know how to send error:\", message);\n    if (head) {\n      res.writeHead(500, {});\n      res.end(\"\");\n    } else {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end(\"Error: \" + message + \"\\n\");\n    }\n  }\n};\n\nvar send400 = function(res, message) {\n  res.writeHead(400, {'Content-Type': 'text/plain'});\n  res.end(message);\n};\n\nvar send200 = function(res, message) {\n  if (message == null) message = \"OK\\n\";\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(message);\n};\n\nvar sendJSON = function(res, obj) {\n  res.writeHead(200, {'Content-Type': 'application/json'});\n  res.end(JSON.stringify(obj) + '\\n');\n};\n\n// Expect the request to contain JSON data. Read all the data and try to JSON\n// parse it.\nvar expectJSONObject = function(req, res, callback) {\n  pump(req, function(data) {\n    var obj;\n    try {\n      obj = JSON.parse(data);\n    } catch (err) {\n      send400(res, 'Supplied JSON invalid');\n      return;\n    }\n\n    return callback(obj);\n  });\n};\n\nvar pump = function(req, callback) {\n  // Currently using the old streams API..\n  var data = '';\n  req.on('data', function(chunk) {\n    return data += chunk;\n  });\n  return req.on('end', function() {\n    return callback(data);\n  });\n};\n\n\n\n// ***** Actual logic\n\nmodule.exports = function(share) {\n  var router = new Router();\n\n  var auth = function(req, res, next) {\n    if (req.session && req.session.shareAgent) {\n      req._shareAgent = req.session.shareAgent;\n    } else {\n      var userAgent = req._shareAgent = share.createAgent(req);\n      if (req.session) req.session.shareAgent = userAgent;\n    }\n\n    next();\n  };\n\n  \n  // GET returns the document snapshot. The version and type are sent as headers.\n  // I'm not sure what to do with document metadata - it is inaccessable for now.\n  router.get('/:cName/:docName', auth, function(req, res, next) {\n    req._shareAgent.fetch(req.params.cName, req.params.docName, function(err, doc) {\n      if (err) {\n        if (req.method === \"HEAD\") {\n          sendError(res, err, true);\n        } else {\n          sendError(res, err);\n        }\n        return;\n      }\n\n      res.setHeader('X-OT-Version', doc.v);\n\n      if (!doc.type) {\n        send404(res, 'Document does not exist\\n');\n        return;\n      }\n\n      res.setHeader('X-OT-Type', doc.type);\n      res.setHeader('ETag', doc.v);\n\n      // If not GET request, presume HEAD request\n      if (req.method !== 'GET') {\n        send200(res, '');\n        return;\n      }\n\n      var content;\n      var query = url.parse(req.url,true).query;\n      if (query.envelope == 'true')\n      {\n        content = doc;\n      } else {\n        content = doc.data;\n      }\n\n      if (typeof doc.data === 'string') {\n        send200(res, content);\n      } else {\n        sendJSON(res, content);\n      }\n    });\n  });\n\n  // Get operations. You can use from:X and to:X to specify the range of ops you want.\n  router.get('/:cName/:docName/ops', auth, function(req, res, next) {\n    var from = 0, to = null;\n\n    var query = url.parse(req.url, true).query;\n\n    if (query && query.from) from = parseInt(query.from)|0;\n    if (query && query.to) to = parseInt(query.to)|0;\n\n    req._shareAgent.getOps(req.params.cName, req.params.docName, from, to, function(err, ops) {\n      if (err)\n        sendError(res, err);\n      else\n        sendJSON(res, ops);\n    });\n  });\n\n  var submit = function(req, res, opData, sendOps) {\n    // The backend allows the version to be unspecified - it assumes the most\n    // recent version in that case. This is useful behaviour when you want to\n    // create a document.\n    req._shareAgent.submit(req.params.cName, req.params.docName, opData, {}, function(err, v, ops) {\n      if (err) return sendError(res, err);\n\n      res.setHeader('X-OT-Version', v);\n      if (sendOps)\n        sendJSON(res, ops);\n      else\n        send200(res);\n    });\n  };\n\n  // POST submits op data to the document. POST {op:[...], v:100}\n  router.post('/:cName/:docName', auth, function(req, res, next) {\n    expectJSONObject(req, res, function(opData) {\n      submit(req, res, opData, true);\n    });\n  });\n  \n\n  // PUT is used to create a document. The contents are a JSON object with\n  // {type:TYPENAME, data:{initial data} meta:{...}}\n  // PUT {...} is equivalent to POST {create:{...}}\n  router.put('/:cName/:docName', auth, function(req, res, next) {\n    expectJSONObject(req, res, function(create) {\n      submit(req, res, {create:create});\n    });\n  });\n\n  // DELETE deletes a document. It is equivalent to POST {del:true}\n  router.delete('/:cName/:docName', auth, function(req, res, next) {\n    submit(req, res, {del:true});\n  });\n\n  return router.middleware;\n};\n\n","/home/travis/build/npmtest/node-npmtest-share/node_modules/share/lib/types/json-api.js":"// JSON document API for the 'json0' type.\n\nvar type = require('ot-json0').type;\n\n// Helpers\n\nfunction depath(path) {\n  if (path.length === 1 && path[0].constructor === Array) {\n    return path[0];\n  } else {\n    return path;\n  }\n}\n\nfunction traverse(snapshot, path) {\n  var key = 'data';\n  var elem = { data: snapshot };\n\n  for (var i = 0; i < path.length; i++) {\n    elem = elem[key];\n    key = path[i];\n    if (typeof elem === 'undefined') {\n      throw new Error('bad path');\n    }\n  }\n\n  return {\n    elem: elem,\n    key: key\n  };\n}\n\nfunction pathEquals(p1, p2) {\n  if (p1.length !== p2.length) {\n    return false;\n  }\n  for (var i = 0; i < p1.length; ++i) {\n    if (p1[i] !== p2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction containsPath(p1, p2) {\n  if (p1.length < p2.length) return false;\n  return pathEquals( p1.slice(0,p2.length), p2);\n}\n\n// does nothing, used as a default callback\nfunction nullFunction() {}\n\n// given a path represented as an array or a number, normalize to an array\n// whole numbers are converted to integers.\nfunction normalizePath(path) {\n  if (path instanceof Array) {\n    return path;\n  }\n  if (typeof(path) == \"number\") {\n    return [path];\n  }\n  // if (typeof(path) == \"string\") {\n  //   path = path.split(\".\");\n  //   var out = [];\n  //   for (var i=0; i<path.length; i++) {\n  //     var part = path[i];\n  //     if (String(parseInt(part, 10)) == part) {\n  //       out.push(parseInt(part, 10));\n  //     } else {\n  //       out.push(part);\n  //     }\n  //   }\n  //   return out;\n  // }\n}\n\n// helper for creating functions with the method signature func([path],arg1,arg2,...,[cb])\n// populates an array of arguments with a default path and callback\nfunction normalizeArgs(obj, args, func, requiredArgsCount){\n  args = Array.prototype.slice.call(args);\n  var path_prefix = obj.path || [];\n\n  if (func.length > 1 && typeof args[args.length-1] !== 'function') {\n    args.push(nullFunction);\n  }\n\n  if (args.length < (requiredArgsCount || func.length)) {\n    args.unshift(path_prefix);\n  } else {\n    args[0] = path_prefix.concat(normalizePath(args[0]));\n  }\n\n  return func.apply(obj,args);\n}\n\n\n// SubDoc\n// this object is returned from context.createContextAt()\n\nvar SubDoc = function(context, path) {\n  this.context = context;\n  this.path = path || [];\n};\n\nSubDoc.prototype._updatePath = function(op){\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if(c.lm !== undefined && containsPath(this.path,c.p)){\n      var new_path_prefix = c.p.slice(0,c.p.length-1);\n      new_path_prefix.push(c.lm);\n      this.path = new_path_prefix.concat(this.path.slice(new_path_prefix.length));\n    }\n  }\n};\n\nSubDoc.prototype.createContextAt = function() {\n  var path = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];\n  return this.context.createContextAt(this.path.concat(depath(path)));\n};\n\nSubDoc.prototype.get = function(path) {\n  return normalizeArgs(this, arguments, function(path){\n    return this.context.get(path);\n  });\n};\n\nSubDoc.prototype.set = function(path, value, cb) {\n  return normalizeArgs(this, arguments, function(path, value, cb){\n    return this.context.set(path, value, cb);\n  });\n};\n\nSubDoc.prototype.insert = function(path, value, cb) {\n  return normalizeArgs(this, arguments, function(path, value, cb){\n    return this.context.insert(path, value, cb);\n  });\n};\n\nSubDoc.prototype.remove = function(path, len, cb) {\n  return normalizeArgs(this, arguments, function(path, len, cb) {\n    return this.context.remove(path, len, cb);\n  }, 2);\n};\n\nSubDoc.prototype.push = function(path, value, cb) {\n  return normalizeArgs(this, arguments, function(path, value, cb) {\n      var _ref = traverse(this.context.getSnapshot(), path);\n      var len = _ref.elem[_ref.key].length;\n      path.push(len);\n    return this.context.insert(path, value, cb);\n  });\n};\n\nSubDoc.prototype.move = function(path, from, to, cb) {\n  return normalizeArgs(this, arguments, function(path, from, to, cb) {\n    return this.context.move(path, from, to, cb);\n  });\n};\n\nSubDoc.prototype.add = function(path, amount, cb) {\n  return normalizeArgs(this, arguments, function(path, amount, cb) {\n    return this.context.add(path, amount, cb);\n  });\n};\n\nSubDoc.prototype.on = function(event, cb) {\n  return this.context.addListener(this.path, event, cb);\n};\n\nSubDoc.prototype.removeListener = function(l) {\n  return this.context.removeListener(l);\n};\n\nSubDoc.prototype.getLength = function(path) {\n  return normalizeArgs(this, arguments, function(path) {\n    return this.context.getLength(path);\n  });\n};\n\n// DEPRECATED\nSubDoc.prototype.getText = function(path) {\n  return normalizeArgs(this, arguments, function(path) {\n    return this.context.getText(path);\n  });\n};\n\n// DEPRECATED\nSubDoc.prototype.deleteText = function(path, pos, length, cb) {\n  return normalizeArgs(this, arguments, function(path, pos, length, cb) {\n    return this.context.deleteText(path, length, pos, cb);\n  });\n};\n\nSubDoc.prototype.destroy = function() {\n  this.context._removeSubDoc(this);\n};\n\n\n// JSON API methods\n// these methods are mixed in to the context return from doc.createContext()\n\ntype.api = {\n\n  provides: {\n    json: true\n  },\n\n  _fixComponentPaths: function(c) {\n    if (!this._listeners) {\n      return;\n    }\n    if (c.na !== undefined || c.si !== undefined || c.sd !== undefined) {\n      return;\n    }\n\n    var to_remove = [];\n    var _ref = this._listeners;\n\n    for (var i = 0; i < _ref.length; i++) {\n      var l = _ref[i];\n      var dummy = {\n        p: l.path,\n        na: 0\n      };\n      var xformed = type.transformComponent([], dummy, c, 'left');\n      if (xformed.length === 0) {\n        to_remove.push(i);\n      } else if (xformed.length === 1) {\n        l.path = xformed[0].p;\n      } else {\n        throw new Error(\"Bad assumption in json-api: xforming an 'na' op will always result in 0 or 1 components.\");\n      }\n    }\n\n    to_remove.sort(function(a, b) {\n      return b - a;\n    });\n\n    var _results = [];\n    for (var j = 0; j < to_remove.length; j++) {\n      i = to_remove[j];\n      _results.push(this._listeners.splice(i, 1));\n    }\n\n    return _results;\n  },\n\n  _fixPaths: function(op) {\n    var _results = [];\n    for (var i = 0; i < op.length; i++) {\n      var c = op[i];\n      _results.push(this._fixComponentPaths(c));\n    }\n    return _results;\n  },\n\n  _submit: function(op, callback) {\n    this._fixPaths(op);\n    return this.submitOp(op, callback);\n  },\n\n  _addSubDoc: function(subdoc){\n    this._subdocs || (this._subdocs = []);\n    this._subdocs.push(subdoc);\n  },\n\n  _removeSubDoc: function(subdoc){\n    this._subdocs || (this._subdocs = []);\n    for(var i = 0; i < this._subdocs.length; i++){\n      if(this._subdocs[i] === subdoc) this._subdocs.splice(i,1);\n      return;\n    }\n  },\n\n  _updateSubdocPaths: function(op){\n    this._subdocs || (this._subdocs = []);\n    for(var i = 0; i < this._subdocs.length; i++){\n      this._subdocs[i]._updatePath(op);\n    }\n  },\n\n  createContextAt: function() {\n    var path = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : [];\n    var subdoc =  new SubDoc(this, depath(path));\n    this._addSubDoc(subdoc);\n    return subdoc;\n  },\n\n  get: function(path) {\n    if (!path) return this.getSnapshot();\n    return normalizeArgs(this,arguments,function(path){\n      var _ref = traverse(this.getSnapshot(), path);\n      return _ref.elem[_ref.key];\n    });\n  },\n\n  set: function(path, value, cb) {\n    return normalizeArgs(this, arguments, function(path, value, cb) {\n      var _ref = traverse(this.getSnapshot(), path);\n      var elem = _ref.elem;\n      var key = _ref.key;\n      var op = {\n        p: path\n      };\n\n      if (elem.constructor === Array) {\n        op.li = value;\n        if (typeof elem[key] !== 'undefined') {\n          op.ld = elem[key];\n        }\n      } else if (typeof elem === 'object') {\n        op.oi = value;\n        if (typeof elem[key] !== 'undefined') {\n          op.od = elem[key];\n        }\n      } else {\n        throw new Error('bad path');\n      }\n\n      return this._submit([op], cb);\n    });\n  },\n\n  remove: function(path, len, cb) {\n    return normalizeArgs(this, arguments, function(path, len, cb) {\n      if (!cb && len instanceof Function) {\n        cb = len;\n        len = null;\n      }\n      // if there is no len argument, then we are removing a single item from either a list or a hash\n      var _ref, elem, op, key;\n      if (len === null || len === undefined) {\n        _ref = traverse(this.getSnapshot(), path);\n        elem = _ref.elem;\n        key = _ref.key;\n        op = {\n          p: path\n        };\n\n        if (typeof elem[key] === 'undefined') {\n          throw new Error('no element at that path');\n        }\n\n        if (elem.constructor === Array) {\n          op.ld = elem[key];\n        } else if (typeof elem === 'object') {\n          op.od = elem[key];\n        } else {\n          throw new Error('bad path');\n        }\n        return this._submit([op], cb);\n      } else {\n        var pos;\n        pos = path.pop();\n        _ref = traverse(this.getSnapshot(), path);\n        elem = _ref.elem;\n        key = _ref.key;\n        if (typeof elem[key] === 'string') {\n          op = {\n            p: path.concat(pos),\n            sd: _ref.elem[_ref.key].slice(pos, pos + len)\n          };\n          return this._submit([op], cb);\n        } else if (elem[key].constructor === Array) {\n          var ops = [];\n          for (var i=pos; i<pos+len; i++) {\n            ops.push({\n              p: path.concat(pos),\n              ld: elem[key][i]\n            });\n          }\n          return this._submit(ops, cb);\n        } else {\n          throw new Error('element at path does not support range');\n        }\n      }\n    }, 2);\n  },\n\n  insert: function(path, value, cb) {\n    return normalizeArgs(this, arguments, function(path, value, cb) {\n      var pos = path.pop();\n      var _ref = traverse(this.getSnapshot(), path);\n      var elem = _ref.elem;\n      var key = _ref.key;\n      var op = {\n        p: path.concat(pos)\n      };\n\n      if (elem[key].constructor === Array) {\n        op.li = value;\n      } else if (typeof elem[key] === 'string') {\n        op.si = value;\n      }\n      return this._submit([op], cb);\n    });\n  },\n\n  move: function(path, from, to, cb) {\n    return normalizeArgs(this, arguments, function(path, from, to, cb) {\n      var self = this;\n      var op = [\n        {\n          p: path.concat(from),\n          lm: to\n        }\n      ];\n\n      return this._submit(op, function(){\n        self._updateSubdocPaths(op);\n        if(cb) cb.apply(cb, arguments);\n      });\n    });\n  },\n\n  push: function(path, value, cb) {\n    return normalizeArgs(this, arguments, function(path, value, cb) {\n      var _ref = traverse(this.getSnapshot(), path);\n      var len = _ref.elem[_ref.key].length;\n      path.push(len);\n      return this.insert(path, value, cb);\n    });\n  },\n\n  add: function(path, amount, cb) {\n    return normalizeArgs(this, arguments, function(path, value, cb) {\n      var op = [\n        {\n          p: path,\n          na: amount\n        }\n      ];\n      return this._submit(op, cb);\n    });\n  },\n\n  getLength: function(path) {\n      return normalizeArgs(this, arguments, function(path) {\n        return this.get(path).length;\n      });\n  },\n\n  getText: function(path) {\n    return normalizeArgs(this, arguments, function(path) {\n      console.warn(\"Deprecated. Use `get()` instead\");\n      return this.get(path);\n    });\n  },\n\n  deleteText: function(path, length, pos, cb) {\n    return normalizeArgs(this, arguments, function(path, length, pos, cb) {\n      console.warn(\"Deprecated. Use `remove(path, length, cb)` instead\");\n      var _ref = traverse(this.getSnapshot(), path);\n      var op = [\n        {\n          p: path.concat(pos),\n          sd: _ref.elem[_ref.key].slice(pos, pos + length)\n        }\n      ];\n\n      return this._submit(op, cb);\n    });\n  },\n\n  addListener: function(path, event, cb) {\n    return normalizeArgs(this, arguments, function(path, value, cb) {\n      var listener = {\n        path: path,\n        event: event,\n        cb: cb\n      };\n      this._listeners || (this._listeners = []);\n      this._listeners.push(listener);\n      return listener;\n    });\n  },\n\n  removeListener: function(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    var i = this._listeners.indexOf(listener);\n    if (i < 0) {\n      return false;\n    }\n    this._listeners.splice(i, 1);\n    return true;\n  },\n\n  _onOp: function(op) {\n    for (var i = 0; i < op.length; i++) {\n      var c = op[i];\n      this._fixComponentPaths(c);\n\n      if(c.lm !== undefined) {\n        this._updateSubdocPaths([c]);\n      }\n\n      var match_path = c.na === undefined ? c.p.slice(0, c.p.length - 1) : c.p;\n\n      for (var l = 0; l < this._listeners.length; l++) {\n        var listener = this._listeners[l];\n        var cb = listener.cb;\n\n        if (pathEquals(listener.path, match_path)) {\n          switch (listener.event) {\n            case 'insert':\n              if (c.li !== undefined && c.ld === undefined) {\n                cb(c.p[c.p.length - 1], c.li);\n              } else if (c.oi !== undefined && c.od === undefined) {\n                cb(c.p[c.p.length - 1], c.oi);\n              } else if (c.si !== undefined) {\n                cb(c.p[c.p.length - 1], c.si);\n              }\n              break;\n            case 'delete':\n              if (c.li === undefined && c.ld !== undefined) {\n                cb(c.p[c.p.length - 1], c.ld);\n              } else if (c.oi === undefined && c.od !== undefined) {\n                cb(c.p[c.p.length - 1], c.od);\n              } else if (c.sd !== undefined) {\n                cb(c.p[c.p.length - 1], c.sd);\n              }\n              break;\n            case 'replace':\n              if (c.li !== undefined && c.ld !== undefined) {\n                cb(c.p[c.p.length - 1], c.ld, c.li);\n              } else if (c.oi !== undefined && c.od !== undefined) {\n                cb(c.p[c.p.length - 1], c.od, c.oi);\n              }\n              break;\n            case 'move':\n              if (c.lm !== undefined) {\n                cb(c.p[c.p.length - 1], c.lm);\n              }\n              break;\n            case 'add':\n              if (c.na !== undefined) {\n                cb(c.na);\n              }\n          }\n        }\n\n        if (type.canOpAffectPath(c, listener.path) && listener.event === 'child op') {\n          var child_path = c.p.slice(listener.path.length);\n          cb(child_path, c);\n        }\n      }\n    }\n  }\n};\n"}